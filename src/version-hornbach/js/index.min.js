/**
 * Hornbach Arcade Style Game SAT DATA
 * Author   : J. Pfeifer @egplusww.com
 * Created  : 06.12.2020
 * Modified : 31.12.2020 | 21.06.21 | 06.07.21 | 08.07.21 |
*/
(function () {

  'use strict';

  window.EGP = {
    language: {
      DE: [
        { id: 'start-btn', text: 'Spiel Laden', size: '25px', lineHeight: '39px' },
        { id: 'play-btn', text: 'Spielen', size: '25px', lineHeight: '39px' },
        { id: 'again-btn', text: 'Nochmal', size: '25px', lineHeight: '39px' },
        { id: 'back-btn', text: 'Zurück', size: '25px', lineHeight: '39px' },
        { id: 'share-btn', text: 'Teilen', size: '25px', lineHeight: '39px' },
        { id: 'submit-btn', text: 'Bestätigen', size: '25px', lineHeight: '39px' },
        { id: 'video-intro', src: './assets/intro-new.mp4', poster: './assets/intro.jpg', loop: true },
        { id: 'video-info', src: './assets/info.mp4', poster: '', loop: false },
        { id: 'video-result-1', src: './assets/01_game-end.mp4', poster: '', loop: false },
        { id: 'video-result-2', src: './assets/02_game-end.mp4', poster: '', loop: false },
        { id: 'video-result-3', src: './assets/03_game-end.mp4', poster: '', loop: false },
        { id: 'video-result-4', src: './assets/04_game-end.mp4', poster: '', loop: false },
        { id: 'video-result-5', src: './assets/05_game-end.mp4', poster: '', loop: false },
        { id: 'hornbach-logo', text: 'Auf zu hornbach', href: 'https://www.hornbach.de/' },
        { id: 'social-share', text: 'Jetzt weitersagen:', content: 'Spiele jetzt mit und sichere Dir ewigen Ruhm.' },
        { id: 'footer-imprint', text: 'Impressum', href: 'https://www.hornbach.de/services/impressum/' },
        { id: 'footer-agb', text: 'AGB', href: 'https://www.hornbach.de/services/allgemeine-geschaeftsbedingungen-agb/' },
        { id: 'footer-daten', text: 'Datenschutzhinweise', href: 'https://www.hornbach.de/services/datenschutzhinweise/' },
      ],
    },
    data: {
      OFFSET_TRAIN: 7,
      SCROLL_SPEED_Y: 3.25,
      SCROLL_SPEED_Y_MAX: 12.0,
      SCROLL_SPEED_ACC: 0.15,
      SCROLL_SPEED_ACCELERATION: 0.0005,
      FRICTION_DEVICE: 0.5,
      MOVE_SPEED_X: 6,
      DRAG_SPEED_X: 8,
      BESERK_TIME: 6,
      language: 'DE',
      currentLevel: 0,
      score: 0,
      nickname: '',
      life: 3,
      isSoundOn: true,
      sounds: {
        start: { src: 'sounds/INTRO_MUSIK_4s.mp3' },
        end: { src: 'sounds/INTRO_MIX_5s.mp3' },
        items: { src: 'sounds/Pling_1.mp3' },
        mitarbeiter: { src: 'sounds/11_item.mp3' },
        hupe: { src: 'sounds/INTRO_HUPE.mp3' },
        crash: { src: 'sounds/hollow_impact_2.mp3' },
        booster: { src: 'sounds/BoosterAP17_MusicalGames_6s.mp3' },
      },
      player: {
        width: 32,
        height: 125,
        heightStart: 60,
        heightMid: 34,
        heightEnd: 31
      },
      levels: [
        {
          name: 'level-1',
          collectableItems: [
            { x: 116, y: 194, width: 25, height: 20, name: 'item-flower', score: 10 },
            { x: 173, y: 272, width: 25, height: 20, name: 'item-flower', score: 10 },
            { x: 177, y: 449, width: 25, height: 20, name: 'item-flower', score: 10 },
            { x: 117, y: 513, width: 25, height: 20, name: 'item-flower', score: 10 },
            { x: 177, y: 589, width: 8, height: 25, name: 'item-shovel', score: 10 },
            { x: 93, y: 760, width: 8, height: 25, name: 'item-shovel', score: 10 },
            { x: 280, y: 890, width: 22, height: 47, name: 'item-mitarbeiter', score: 50 },
            { x: 131, y: 1163, width: 8, height: 25, name: 'item-shovel', score: 10 },
            { x: 178, y: 1229, width: 25, height: 20, name: 'item-flower', score: 10 },
            { x: 135, y: 1369, width: 8, height: 25, name: 'item-shovel', score: 10 },
            { x: 175, y: 1469, width: 25, height: 20, name: 'item-flower', score: 10 },
            { x: 235, y: 1495, width: 25, height: 20, name: 'item-flower', score: 10 },
          ],
          walls: [
            { x: 18, y: 380, width: 112, height: 25, name: 'wall-1' },
            { x: 202, y: 380, width: 100, height: 25, name: 'wall-2' },
            { x: 202, y: 683, width: 100, height: 25, name: 'wall-2' },
            { x: 18, y: 1030, width: 112, height: 25, name: 'wall-1' },
            { x: 202, y: 1330, width: 100, height: 25, name: 'wall-2' },
          ],
          width: 320,
          height: 1920,
        },
        {
          name: 'level-2',
          collectableItems: [
            { x: 106, y: 214, width: 22, height: 22, name: 'item-bucket', score: 10 },
            { x: 173, y: 292, width: 22, height: 22, name: 'item-bucket', score: 10 },
            { x: 247, y: 419, width: 15, height: 25, name: 'item-brush', score: 10 },
            { x: 157, y: 509, width: 15, height: 25, name: 'item-brush', score: 10 },
            { x: 87, y: 583, width: 22, height: 22, name: 'item-bucket', score: 10 },
            { x: 173, y: 760, width: 27, height: 27, name: 'item-hornbach', score: 100 },
            { x: 110, y: 911, width: 22, height: 22, name: 'item-bucket', score: 10 },
            { x: 81, y: 1163, width: 15, height: 25, name: 'item-brush', score: 10 },
            { x: 188, y: 1229, width: 22, height: 22, name: 'item-bucket', score: 10 },
            { x: 135, y: 1369, width: 15, height: 25, name: 'item-brush', score: 10 },
            { x: 280, y: 1400, width: 22, height: 47, name: 'item-mitarbeiter', score: 50 },
          ],
          walls: [
            { x: 18, y: 1040, width: 84, height: 48, name: 'stapler-0' },
            { x: 18, y: 440, width: 84, height: 48, name: 'stapler-0' }
          ],
          width: 320,
          height: 1920,
        },
        {
          name: 'level-3',
          collectableItems: [
            { x: 177, y: 409, width: 16, height: 24, name: 'item-hammer', score: 10 },
            { x: 247, y: 500, width: 16, height: 24, name: 'item-hammer', score: 10 },
            { x: 57, y: 508, width: 25, height: 25, name: 'item-saw', score: 10 },
            { x: 173, y: 760, width: 25, height: 25, name: 'item-saw', score: 10 },
            { x: 110, y: 911, width: 16, height: 24, name: 'item-hammer', score: 10 },
            { x: 280, y: 1000, width: 22, height: 47, name: 'item-mitarbeiter', score: 50 },
            { x: 81, y: 1210, width: 16, height: 24, name: 'item-hammer', score: 10 },
            { x: 258, y: 1229, width: 16, height: 24, name: 'item-hammer', score: 10 },
            { x: 135, y: 1369, width: 25, height: 25, name: 'item-saw', score: 10 },
          ],
          walls: [
            { x: 18, y: 1140, width: 84, height: 48, name: 'stapler-0' },
            { x: 18, y: 540, width: 84, height: 48, name: 'stapler-0' },
          ],
          width: 320,
          height: 1920,
        },
        {
          name: 'level-4',
          collectableItems: [
            { x: 106, y: 194, width: 15, height: 25, name: 'item-bausteine', score: 10 },
            { x: 173, y: 272, width: 15, height: 25, name: 'item-bausteine', score: 10 },
            { x: 169, y: 359, width: 21, height: 25, name: 'item-cement', score: 10 },
            { x: 57, y: 460, width: 15, height: 25, name: 'item-bausteine', score: 10 },
            { x: 154, y: 740, width: 21, height: 25, name: 'item-cement', score: 10 },
            { x: 190, y: 1000, width: 27, height: 27, name: 'item-hornbach', score: 100 },
            { x: 280, y: 800, width: 22, height: 47, name: 'item-mitarbeiter', score: 50 },
            { x: 81, y: 1163, width: 21, height: 25, name: 'item-cement', score: 10 },
            { x: 100, y: 1329, width: 15, height: 25, name: 'item-bausteine', score: 10 },
            { x: 130, y: 1440, width: 21, height: 25, name: 'item-cement', score: 10 },
            { x: 235, y: 1520, width: 15, height: 25, name: 'item-bausteine', score: 10 },
          ],
          walls: [
            { x: 18, y: 360, width: 84, height: 48, name: 'stapler-0' },
            { x: 18, y: 860, width: 84, height: 48, name: 'stapler-0' },
            { x: 94, y: 569, width: 208, height: 20, name: 'wall-4' },
            { x: 18, y: 921, width: 66, height: 20, name: 'wall-3-2' },
            { x: 172, y: 1209, width: 130, height: 20, name: 'wall-3' },
          ],
          width: 320,
          height: 1920,
        },
        {
          name: 'level-5',
          collectableItems: [
            { x: 103, y: 193, width: 26, height: 22, name: 'item-brause', score: 10 },
            { x: 173, y: 272, width: 26, height: 22, name: 'item-brause', score: 10 },
            { x: 94, y: 474, width: 26, height: 22, name: 'item-brause', score: 10 },
            { x: 184, y: 550, width: 16, height: 24, name: 'item-toilet', score: 10 },
            { x: 173, y: 760, width: 16, height: 24, name: 'item-toilet', score: 10 },
            { x: 280, y: 810, width: 22, height: 47, name: 'item-mitarbeiter', score: 50 },
            { x: 148, y: 1134, width: 26, height: 22, name: 'item-brause', score: 10 },
            { x: 205, y: 1230, width: 16, height: 24, name: 'item-toilet', score: 10 },
            { x: 135, y: 1369, width: 26, height: 22, name: 'item-brause', score: 10 },
            { x: 192, y: 1510, width: 16, height: 24, name: 'item-toilet', score: 10 },
          ],
          walls: [
            { x: 16, y: 860, width: 84, height: 48, name: 'stapler-0' },
            { x: 16, y: 345, width: 112, height: 25, name: 'wall-5' },
            { x: 204, y: 454, width: 100, height: 25, name: 'wall-6' },
            { x: 16, y: 562, width: 112, height: 25, name: 'wall-7' },
            { x: 16, y: 1299, width: 112, height: 25, name: 'wall-5' },
            { x: 204, y: 1409, width: 100, height: 25, name: 'wall-6' },
            { x: 16, y: 1517, width: 112, height: 25, name: 'wall-7' },
          ],
          width: 320,
          height: 1920,
        },
        {
          name: 'level-1',
          collectableItems: [
            { x: 56, y: 194, width: 25, height: 20, name: 'item-flower', score: 10 },
            { x: 173, y: 272, width: 25, height: 20, name: 'item-flower', score: 10 },
            { x: 177, y: 479, width: 25, height: 20, name: 'item-flower', score: 10 },
            { x: 57, y: 513, width: 25, height: 20, name: 'item-flower', score: 10 },
            { x: 217, y: 589, width: 8, height: 25, name: 'item-shovel', score: 10 },
            { x: 173, y: 760, width: 8, height: 25, name: 'item-shovel', score: 10 },
            { x: 280, y: 890, width: 22, height: 47, name: 'item-mitarbeiter', score: 50 },
            { x: 81, y: 1163, width: 8, height: 25, name: 'item-shovel', score: 10 },
            { x: 258, y: 1229, width: 25, height: 20, name: 'item-flower', score: 10 },
            { x: 135, y: 1369, width: 8, height: 25, name: 'item-shovel', score: 10 },
            { x: 175, y: 1469, width: 25, height: 20, name: 'item-flower', score: 10 },
            { x: 235, y: 1495, width: 25, height: 20, name: 'item-flower', score: 10 },
          ],
          walls: [
            { x: 18, y: 380, width: 112, height: 25, name: 'wall-1' },
            { x: 202, y: 380, width: 100, height: 25, name: 'wall-2' },
            { x: 202, y: 683, width: 100, height: 25, name: 'wall-2' },
            { x: 18, y: 1030, width: 112, height: 25, name: 'wall-1' },
            { x: 202, y: 1030, width: 100, height: 25, name: 'wall-2' },
          ],
          width: 320,
          height: 1920,
        },
        {
          name: 'level-2',
          collectableItems: [
            { x: 56, y: 214, width: 22, height: 22, name: 'item-bucket', score: 10 },
            { x: 173, y: 292, width: 22, height: 22, name: 'item-bucket', score: 10 },
            { x: 247, y: 419, width: 15, height: 25, name: 'item-brush', score: 10 },
            { x: 247, y: 509, width: 15, height: 25, name: 'item-brush', score: 10 },
            { x: 57, y: 513, width: 22, height: 22, name: 'item-bucket', score: 10 },
            { x: 173, y: 760, width: 27, height: 27, name: 'item-hornbach', score: 100 },
            { x: 110, y: 911, width: 22, height: 22, name: 'item-bucket', score: 10 },
            { x: 81, y: 1163, width: 15, height: 25, name: 'item-brush', score: 10 },
            { x: 258, y: 1229, width: 22, height: 22, name: 'item-bucket', score: 10 },
            { x: 135, y: 1369, width: 15, height: 25, name: 'item-brush', score: 10 },
            { x: 280, y: 1400, width: 22, height: 47, name: 'item-mitarbeiter', score: 50 },
          ],
          walls: [
            { x: 18, y: 1040, width: 84, height: 48, name: 'stapler-0' },
            { x: 18, y: 440, width: 84, height: 48, name: 'stapler-0' }
          ],
          width: 320,
          height: 1920,
        },
        {
          name: 'level-3',
          collectableItems: [
            { x: 177, y: 409, width: 16, height: 24, name: 'item-hammer', score: 10 },
            { x: 247, y: 500, width: 16, height: 24, name: 'item-hammer', score: 10 },
            { x: 57, y: 508, width: 25, height: 25, name: 'item-saw', score: 10 },
            { x: 173, y: 760, width: 25, height: 25, name: 'item-saw', score: 10 },
            { x: 110, y: 911, width: 16, height: 24, name: 'item-hammer', score: 10 },
            { x: 280, y: 1000, width: 22, height: 47, name: 'item-mitarbeiter', score: 50 },
            { x: 81, y: 1210, width: 16, height: 24, name: 'item-hammer', score: 10 },
            { x: 258, y: 1229, width: 16, height: 24, name: 'item-hammer', score: 10 },
            { x: 135, y: 1369, width: 25, height: 25, name: 'item-saw', score: 10 },
          ],
          walls: [
            { x: 18, y: 1140, width: 84, height: 48, name: 'stapler-0' },
            { x: 18, y: 540, width: 84, height: 48, name: 'stapler-0' },
          ],
          width: 320,
          height: 1920,
        },
        {
          name: 'level-4',
          collectableItems: [
            { x: 56, y: 194, width: 15, height: 25, name: 'item-bausteine', score: 10 },
            { x: 173, y: 272, width: 15, height: 25, name: 'item-bausteine', score: 10 },
            { x: 247, y: 359, width: 21, height: 25, name: 'item-cement', score: 10 },
            { x: 57, y: 460, width: 15, height: 25, name: 'item-bausteine', score: 10 },
            { x: 154, y: 740, width: 21, height: 25, name: 'item-cement', score: 10 },
            { x: 190, y: 1000, width: 27, height: 27, name: 'item-hornbach', score: 100 },
            { x: 280, y: 800, width: 22, height: 47, name: 'item-mitarbeiter', score: 50 },
            { x: 81, y: 1163, width: 21, height: 25, name: 'item-cement', score: 10 },
            { x: 190, y: 1329, width: 15, height: 25, name: 'item-bausteine', score: 10 },
            { x: 70, y: 1440, width: 21, height: 25, name: 'item-cement', score: 10 },
            { x: 235, y: 1520, width: 15, height: 25, name: 'item-bausteine', score: 10 },
          ],
          walls: [
            { x: 18, y: 360, width: 84, height: 48, name: 'stapler-0' },
            { x: 18, y: 860, width: 84, height: 48, name: 'stapler-0' },
            { x: 94, y: 569, width: 208, height: 20, name: 'wall-4' },
            { x: 18, y: 921, width: 130, height: 20, name: 'wall-3' },
            { x: 94, y: 1209, width: 208, height: 20, name: 'wall-4' },
          ],
          width: 320,
          height: 1920,
        },
        {
          name: 'level-5',
          collectableItems: [
            { x: 53, y: 193, width: 26, height: 22, name: 'item-brause', score: 10 },
            { x: 173, y: 272, width: 26, height: 22, name: 'item-brause', score: 10 },
            { x: 54, y: 504, width: 26, height: 22, name: 'item-brause', score: 10 },
            { x: 244, y: 570, width: 16, height: 24, name: 'item-toilet', score: 10 },
            { x: 133, y: 730, width: 16, height: 24, name: 'item-toilet', score: 10 },
            { x: 280, y: 810, width: 22, height: 47, name: 'item-mitarbeiter', score: 50 },
            { x: 78, y: 1164, width: 26, height: 22, name: 'item-brause', score: 10 },
            { x: 255, y: 1230, width: 16, height: 24, name: 'item-toilet', score: 10 },
            { x: 135, y: 1369, width: 26, height: 22, name: 'item-brause', score: 10 },
            { x: 232, y: 1470, width: 16, height: 24, name: 'item-toilet', score: 10 },
          ],
          walls: [
            { x: 16, y: 860, width: 84, height: 48, name: 'stapler-0' },
            { x: 16, y: 345, width: 112, height: 25, name: 'wall-5' },
            { x: 204, y: 454, width: 100, height: 25, name: 'wall-6' },
            { x: 16, y: 562, width: 112, height: 25, name: 'wall-7' },
            { x: 16, y: 1299, width: 112, height: 25, name: 'wall-5' },
            { x: 204, y: 1409, width: 100, height: 25, name: 'wall-6' },
            { x: 16, y: 1517, width: 112, height: 25, name: 'wall-7' },
          ],
          width: 320,
          height: 1920,
        },
      ],
      collectedItems: [],
    }
  };

}());

/**
 * Author:   Joerg Pfeifer - @egplusww.com
 * Created:  01.11.2017
 * Modified: 28.02.2019 | 210130 | 210902
 */
(function () {

  'use strict';

  var p,
    content = '',
    obj = {},
    CONTENT_TYPE_PLAIN_TEXT = "text/plain",
    CONTENT_TYPE_HTML_TEXT = "text/html",
    execClipboardCommand = function (content, type) {
      var clipboardListener = function (e) {
        e.clipboardData.setData(type, content);
        e.preventDefault();
      };
      try {
        // try execCommand
        document.addEventListener("copy", clipboardListener);
        document.execCommand('copy');
        document.removeEventListener("copy", clipboardListener);
        /*console.log("+++ copyFlightAdListToClipboard +++");
        console.log(content);
        console.log("+++");*/
      } catch (err) {
        console.warn('Oops, unable to copy');
        return false;
      }
      return true;
    },
    Clipboard = {
      content: '',
      copyText: function copyText(content) {
        this.content = content;
        execClipboardCommand(content, CONTENT_TYPE_PLAIN_TEXT);
        return content;
      }
    };
  //
  // Clipboard Service
  /**
   * Get a well formed list of all latest ads inside campaign
   * @param {object} flight The given flight
   * @param {Array}  ads    The flight ads
   */
  /*obj.copyFlightAds = function (flight, ads) {
      var i, ad, clipboardListener,
          l = ads.length,
          client = flight.client.split('_').join(' ').toUpperCase(),
          folder = flight.folder.split('_').join(' ').toUpperCase();
      content = '<B STYLE="color:#555">' + client + ' - ' + folder + ':</B><BR><UL>';
      for (i = 0; i < l; i++) {
          ad = ads[i];
          //content += ad.format + ' ' + ad.size.raw + ':<br>';
          //content += ad.link.php + '<br><br>';
          content += '<LI STYLE="padding-bottom:6px;text-decoration:underline;">';
          content += '<A HREF="' + ad.link.php + '" TITLE="' + client + ' - ' + folder + ' - ' + ad.size.raw + '">' + ad.format + ' - ' + ad.size.raw + ' - ' + ad.date + ' - ' + ad.version.raw + '</A>';
          content += '</LI>';
      }
      content += '</UL><B STYLE="color:#555">';
      content += 'Overall Links: ' + l + '</B><BR><BR>';
      //
      execClipboardCommand(content, CONTENT_TYPE_HTML_TEXT);
      //
      return content;
  };*/
  window.EGPClipboard = Clipboard;

}());

/**
 * Event.js
 * Author: Joerg Pfeifer - pfeifer@create4web.de
 * Created : 22.04.2020
 * Modified:
 *
 */
(function (window) {

  'use strict';

  if (!window.lib) {
    window.lib = {};
  }

  /**
   * EventDispatcher Mixin prototype
   * @param {object} obj An object for mixin in EventDispatcher
   */
  function EventDispatcher(obj) {
    EventDispatcher.init(obj);
  }

  // save shortcut to prototype
  var p = EventDispatcher.prototype;

  /**
   * EventDispatcher (Mixin)
   * @example EGPlus.initEventDispatcher(obj);
   *              obj.on('eventType', function (event) {});
   *              obj.dispatchEvent('eventType');
   * @param   {object} obj The object to mixin EventDispatcher functionality
   * @returns {object} Returns the same object
   */
  EventDispatcher.init = function (obj) {
    // @property method
    // @property parameters
    var registry = {},
      register = function (type, method, params, once, ob) {
        var handler = {
          method: method || type,
          parameters: params,
          once: typeof once === 'boolean' ? once : false,
          stopPropagation: false
        };
        if (registry.hasOwnProperty(type)) {
          ob.off(type, method);
          registry[type].push(handler);
        } else {
          registry[type] = [handler];
        }
      };

    /**
     * The dispatchEvent method fires listeners for the specified event type
     * @param   {object} event An event type string or an object with a property 'type'
     * @returns {object} Returns this for chaining
     */
    Object.defineProperty(obj, 'dispatchEvent', {
      value: function (event) {
        var listeners, func, handler, i, l,
          type = typeof event === 'string' ? event : event.type;
        //console.info("dispatchEvent", "event:", event, "registry.hasOwnProperty(type):", registry.hasOwnProperty(type));
        if (registry.hasOwnProperty(type)) {
          listeners = registry[type];
          i = listeners.length;
          while (--i > -1) {
            handler = listeners[i];
            func = handler.method;
            if (typeof func === 'string') {
              func = this[func];
            }
            // call handler
            func.apply(this, handler.parameters || [event]);
            // stop propagation
            if (handler.stopPropagation) {
              handler.stopPropagation = false;
              break;
            }
            //console.log("dispatchEvent", "handler:", handler);
            //console.log("dispatchEvent", "func:", func);

            // unregister if once -> 'one'
            if (handler.once && typeof handler.once === 'boolean') {
              listeners.splice(i, 1);
              if (listeners.length === 0) {
                registry[type] = null;
                return this;
              }
            }
          }
        }
        return this;
      }
    });

    /**
     * The has method looks for a registered event of the given type
     * @param   {string}  type The event type as a string
     * @returns {boolean} Returns true if the event type is registered
     */
    Object.defineProperty(obj, 'has', {
      value: function (type) {
        //console.info("has", "type:", type, "registry.hasOwnProperty(type):", registry.hasOwnProperty(type), "registry[type]:", registry[type]);
        return (registry.hasOwnProperty(type) && registry[type] && registry[type].length > 0);
      }
    });

    /**
     * The on method registers a specified event type
     * @param   {string}   type   The event type as a string
     * @param   {function} method A callback function
     * @param   {object}   params An optional parameter object
     * @returns {object}   Returns this for chaining
     */
    Object.defineProperty(obj, 'on', {
      value: function (type, method, params, once) {
        //console.info("on", "type:", type, "registry.hasOwnProperty(type):", registry.hasOwnProperty(type));
        register(type, method, params, typeof once === 'boolean' ? once : false, this);
        return this;
      }
    });

    /**
     * The one method registers a specified event type once
     * @param   {string}   type   The event type as a string
     * @param   {function} method A callback function
     * @param   {object}   params An optional parameter object
     * @returns {object}   Returns this for chaining
     */
    Object.defineProperty(obj, 'one', {
      value: function (type, method, params) {
        //console.info("one", "type:", type, "registry.hasOwnProperty(type):", registry.hasOwnProperty(type));
        register(type, method, params, true, this);
        return this;
      }
    });

    /**
     * The off method unregisters a specified event type
     * @param   {string}   type   The event type as a string
     * @param   {function} method A callback function
     * @returns {object}   Returns this for chaining
     */
    Object.defineProperty(obj, 'off', {
      value: function (type, method) {
        if (registry.hasOwnProperty(type)) {
          //console.info("off", "type:", type, "registry.hasOwnProperty(type):", registry.hasOwnProperty(type), "registry[type]:", registry[type]);
          if (registry[type].length && method && typeof method === 'function') {
            var i, handler, listeners = registry[type],
              l = listeners.length;
            for (i = 0; i < l; i++) {
              handler = listeners[i];
              if (handler.method === method) {
                //console.info("off", "find handler");
                listeners.splice(i, 1);
                return this;
              }
            }
          } else {
            registry[type].splice(0);
          }
        }
        return this;
      }
    });

    /**
     * The off method unregisters a specified event type
     * @param   {string}   type   The event type as a string
     * @param   {function} method A callback function
     * @returns {object}   Returns this for chaining
     */
    Object.defineProperty(obj, 'stopPropagation', {
      value: function (event) {
        var listeners, func, handler, i, l,
          type = typeof event === 'string' ? event : event.type;
        //console.info("dispatchEvent", "event:", event, "registry.hasOwnProperty(type):", registry.hasOwnProperty(type));
        if (registry.hasOwnProperty(type)) {
          listeners = registry[type];
          i = listeners.length;
          while (--i > -1) {
            listeners[i].stopPropagation = true;
            //console.log("dispatchEvent", "handler:", handler);
            //console.log("dispatchEvent", "func:", func);
          }
        }
        return this;
      }
    });

    return obj;
  };

  /**
   * Returns a clone of the Point instance.
   * @method clone
   * @return {Point} a clone of the Point instance.
   **/
  /*p.clone = function () {
  	return new Point(this.x, this.y);
  };*/

  // save EventDispatcher in global namespace as part of lib module
  lib.EventDispatcher = EventDispatcher;

}(window));

/**
 * Point.js
 * Author: Joerg Pfeifer - pfeifer@create4web.de
 * Created : 19.04.2020
 * Modified: 13.01.2021
 */
(function (window) {

  'use strict';

  if (!window.lib) {
    window.lib = {};
  }

  /**
   * Represents a point on a 2 dimensional x / y coordinate system.
   * @param {Number} [x=0] X position.
   * @param {Number} [y=0] Y position.
   */
  function Point(x, y) {
    this.initialize(x, y);
  }

  // save shortcut to prototype
  var p = Point.prototype;
  p.constructor = Point;

  p.x = 0;
  p.y = 0;

  /**
   * Initialization method. Can also be used to reinitialize the instance.
   * @method initialize
   * @param {Number} [x=0] X position.
   * @param {Number} [y=0] Y position.
   * @return {Point} This instance. Useful for chaining method calls.
   */
  p.initialize = function (x, y) {
    this.x = !x ? 0 : x;
    this.y = !y ? 0 : y;
    return this;
  };

  /**
   * Returns a clone of the Point instance.
   * @method clone
   * @return {Point} a clone of the Point instance.
   **/
  p.clone = function () {
    return new Point(this.x, this.y);
  };

  /**
   * Returns the distance between to given points.
   * @method STATIC distance
   * @param {Point} p1
   * @param {Point} p2
   * @return {Number} the distance between p1 and p2.
   **/
  Point.distance = function (p1, p2) {
    var xs = p2.x - p1.x,
      ys = p2.y - p1.y;
    xs = xs * xs;
    ys = ys * ys;
    return Math.sqrt(xs + ys);
  };

  // save Point in global namespace as part of lib module
  lib.Point = Point;

}(window));

/**
 * Rectangle.js
 * Author: Joerg Pfeifer - pfeifer@create4web.de
 * Created : 19.04.2020
 * Modified: 13.01.2021 | 210902
 */
(function (window) {

	'use strict';

	if (!window.lib) {
		window.lib = {};
	}

	/**
	 * Represents a point on a 2 dimensional x / y coordinate system.
	 * @param {Number} [x=0] X position.
	 * @param {Number} [y=0] Y position.
	 */
	function Rectangle(x, y, w, h) {
		this.initialize(x, y, w, h);
	}

	// save shortcut to prototype
	var p = Rectangle.prototype;
	p.constructor = Rectangle;

	p.name = 'Rectangle';
	p.x = 0;
	p.y = 0;
	p.width = 0;
	p.height = 0;

	/**
	 * @method get bottom
	 * @return {Number} Die Summe der Eigenschaften y und height.
	 **/
	Object.defineProperty(p, 'bottom', {
		get: function () {
			return (this.y + this.height);
		},
		enumerable: true
	});
	/**
	 * @method get right
	 * @return {Number} Die Summe der Eigenschaften x und width.
	 **/
	Object.defineProperty(p, 'right', {
		get: function () {
			return (this.x + this.width);
		},
		enumerable: true
	});
	Object.defineProperty(p, 'left', {
		get: function () {
			return this.x;
		},
		enumerable: true
	});
	Object.defineProperty(p, 'top', {
		get: function () {
			return this.y;
		},
		enumerable: true
	});
	/**
	 *
	 * Die Position der rechten unteren Ecke des Rectangle-Objekts, die durch die Werte der Eigenschaften right und bottom angegeben wird.
	 * @method get bottomRight
	 * @return {Point} Der Wert true, wenn das Rectangle-Objekt den angegebenen Punkt enthält, andernfalls false.
	 **/
	Object.defineProperty(p, 'bottomRight', {
		get: function () {
			return new lib.Point(this.right, this.bottom);
		},
		enumerable: true
	});
	Object.defineProperty(p, 'bottomLeft', {
		get: function () {
			return new lib.Point(this.x, this.bottom);
		},
		enumerable: true
	});
	Object.defineProperty(p, 'topLeft', {
		get: function () {
			return new lib.Point(this.x, this.y);
		},
		enumerable: true
	});
	Object.defineProperty(p, 'topRight', {
		get: function () {
			return new lib.Point(this.right, this.y);
		},
		enumerable: true
	});
	Object.defineProperty(p, 'midCenter', {
		get: function () {
			return new lib.Point(Math.round(this.x + this.width / 2), Math.round(this.y + this.height / 2));
		},
		enumerable: true
	});

	/**
	 * Initialization method. Can also be used to reinitialize the instance.
	 * @method initialize
	 * @param {Number} [x=0] X position.
	 * @param {Number} [y=0] Y position.
	 * @param {Number} [w=0] width
	 * @param {Number} [h=0] height
	 * @return {Rectangle} This instance. Useful for chaining method calls.
	 */
	p.initialize = function (x, y, w, h) {
		this.x = x || 0;
		this.y = y || 0;
		this.width = w || 0;
		this.height = h || 0;
		return this;
	};

	/**
	 * Returns a clone of the Rectangle instance.
	 * @method clone
	 * @return {Rectangle} a clone of the Rectangle instance.
	 **/
	p.clone = function () {
		return new Rectangle(this.x, this.y, this.width, this.height);
	};

	/**
	 * @method getIntersection
	 * @param {Rectangle} rect
	 * @return {Rectangle} A new Rectangle object
	 **/
	p.getIntersection = function (rect) {
		var x1 = rect.x,
			y1 = rect.y,
			x2 = x1 + rect.width,
			y2 = y1 + rect.height;
		if (this.x > x1) {
			x1 = this.x;
		}
		if (this.y > y1) {
			y1 = this.y;
		}
		if (this.x + this.width < x2) {
			x2 = this.x + this.width;
		}
		if (this.y + this.height < y2) {
			y2 = this.y + this.height;
		}
		return (x2 <= x1 || y2 <= y1) ? null : new Rectangle(x1, y1, x2 - x1, y2 - y1);
	};

	/**
	 * Vereinigt zwei Rechtecke miteinander, indem der vertikale und horizontale Bereich zwischen ihnen gefüllt wird, sodass ein neues Rectangle-Objekt entsteht.
	 * @method getUnion
	 * @param {Rectangle} rect
	 * @return {Rectangle} The new Rectangle object
	 **/
	p.getUnion = function (rect) {
		var a = this,
			b = rect,
			l = Math.min(a.getLeft(), b.getLeft()),
			r = Math.max(a.getRight(), b.getRight()),
			t = Math.min(a.getTop(), b.getTop()),
			c = Math.max(a.getBottom(), b.getBottom());
		return new Rectangle(l, t, r - l, c - t);
	};

	p.getVolume = function () {
		return this.width * this.height;
	};

	/**
	 * Legt fest, ob der angegebene Punkt innerhalb des rechteckigen Bereichs liegt, der durch das Rectangle-Objekt definiert ist.
	 * Funktioniert auch mit Objekten wenn x, y, width, height vorhanden sind.
	 * @method contains
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Boolean} Der Wert true, wenn das Rectangle-Objekt den angegebenen Punkt enthält, andernfalls false.
	 **/
	p.contains = function (x, y) {
		if (x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height) {
			return true;
		}
		return false;
	};

	/**
	 * Legt fest, ob sich das von dem Parameter „rect“ angegebene Rectangle-Objekt innerhalb dieses Rectangle-Objekts befindet.
	 * @method containsRect
	 * @param {Rectangle} rect
	 * @return {Boolean} Der Wert true, wenn das Rectangle-Objekt das angegebene Rechteck enthält, andernfalls false.
	 **/
	p.containsRect = function (rect) {
		var a = this,
			b = rect;
		if (b.x >= a.x && b.y >= a.y && (b.x + b.width) <= (a.x + a.width) && (b.y + b.height) <= (a.y + a.height)) {
			return true;
		}
		return false;
	};

	/**
	 * @method isEmpty
	 * @return {Boolean}
	 **/
	p.isEmpty = function () {
		if (this.width === 0 && this.height === 0) {
			return true;
		}
		return false;
	};

	/**
	 * Vergrößert das Rectangle-Objekt um die in Pixeln angegebenen Werte.
	 * @method inflate
	 * @param {Number} x
	 * @param {Number} y
	 **/
	p.inflate = function (x, y) {
		var a = this;
		return this.initialize(a.x - x, a.y - y, a.width + 2 * x, a.height + 2 * y);
	};

	/**
	 * Legt fest, ob sich das im Parameter „toIntersect“ angegebene Objekt mit diesem Rectangle-Objekt überschneidet.
	 * @method contains
	 * @param {Rectangle} rect
	 * @return {Boolean}
	 **/
	p.intersects = function (rect) {
		return (rect.x <= this.x + this.width && this.x <= rect.x + rect.width && rect.y <= this.y + this.height && this.y <= rect.y + rect.height);
	};

	/**
	 * Vereinigt dieses Rechteck mit einem anderen, indem der vertikale und horizontale Bereich zwischen ihnen gefüllt wird.
	 * @method contains
	 * @param {Rectangle} rect
	 * @return {Rectangle} Useful for chaining
	 **/
	p.union = function (rect) {
		var a = this,
			b = rect,
			l = Math.min(a.getLeft(), b.getLeft()),
			r = Math.max(a.getRight(), b.getRight()),
			t = Math.min(a.getTop(), b.getTop()),
			c = Math.max(a.getBottom(), b.getBottom());
		return this.initialize(l, t, r - l, c - t);
	};

	// save Rectangle in global namespace as part of lib module
	lib.Rectangle = Rectangle;

}(window));

/**
 * Vector2D.js : Math -> Vector
 * Author  : Joerg Pfeifer - pfeifer@create4web.de
 * Created : 28.12.2017
 * Modified: 04.01.2018 | 13.01.2021
 */
(function () {

  'use strict';

  if (!window.lib) {
    window.lib = {};
  }

  // save shortcut to prototype
  var START_TIME = Date.now(),
    SQRT = Math.sqrt,
    ATAN2 = Math.atan2,
    SIN = Math.sin,
    COS = Math.cos,
    PI = Math.PI,
    p;

  /**
   *
   * @param {Number} [startX=0]
   * @param {Number} [startY=0]
   * @param {Number} [endX=0]
   * @param {Number} [endY=0]
   * @param {Number} [newVX=0]
   * @param {Number} [newVY=0]
   */
  function Vector(startX, startY, endX, endY, newVX, newVY) {
    this.privateA = {
      x: 0,
      y: 0
    };
    this.privateB = {
      x: 0,
      y: 0
    };
    this.privateVX = 0;
    this.privateVY = 0;
    this.update(startX, startY, endX, endY, newVX, newVY);
  }

  // save shortcut to prototype
  p = Vector.prototype;
  p.constructor = Vector;

  p.name = 'Vector2D';

  Object.defineProperty(p, 'a', {
    get: function () {
      return this.privateA;
    },
    enumerable: true
  });
  Object.defineProperty(p, 'b', {
    get: function () {
      return this.privateB;
    },
    enumerable: true
  });
  // velocity -> vx and vy properties
  Object.defineProperty(p, 'vx', {
    get: function () {
      if (this.privateVX === 0) {
        return this.b.x - this.a.x;
      }
      return this.privateVX;
    },
    enumerable: true
  });
  Object.defineProperty(p, 'vy', {
    get: function () {
      if (this.privateVY === 0) {
        return this.b.y - this.a.y;
      }
      return this.privateVY;
    },
    enumerable: true
  });
  //magnitude (length)
  Object.defineProperty(p, 'm', {
    get: function () {
      if (this.vx !== 0 || this.vy !== 0) {
        return SQRT(this.vx * this.vx + this.vy * this.vy);
      } else {
        return 0.001;
      }
    },
    enumerable: true
  });
  //left normal
  Object.defineProperty(p, 'ln', {
    get: function () {
      var ln = new Vector();
      if (this.privateVX === 0 && this.privateVY === 0) {
        ln.update(this.a.x, this.a.y, (this.a.x + this.lx), (this.a.y + this.ly));
      } else {
        ln.update(0, 0, 0, 0, this.vx, this.vy);
      }
      return ln;
    },
    enumerable: true
  });
  //right normal
  Object.defineProperty(p, 'rn', {
    get: function () {
      var rn = new Vector();
      if (this.privateVX === 0 && this.privateVY === 0) {
        rn.update(this.a.x, this.a.y, (this.a.x + this.rx), (this.a.y + this.ry));
      } else {
        rn.update(0, 0, 0, 0, this.vx, this.vy);
      }
      return rn;
    },
    enumerable: true
  });
  // right normal x component
  Object.defineProperty(p, 'rx', {
    get: function () {
      return -this.vy;
    },
    enumerable: true
  });
  // right normal y component
  Object.defineProperty(p, 'ry', {
    get: function () {
      return this.vx;
    },
    enumerable: true
  });
  // left normal x component
  Object.defineProperty(p, 'lx', {
    get: function () {
      return this.vy;
    },
    enumerable: true
  });
  // left normal y component
  Object.defineProperty(p, 'ly', {
    get: function () {
      return -this.vx;
    },
    enumerable: true
  });
  /**
   * Normalized vector
   * The code needs to make sure that
   * the length value isn't zero to avoid
   * returning NaN
   */
  Object.defineProperty(p, 'dx', {
    get: function () {
      if (this.m !== 0) {
        return this.vx / this.m;
      } else {
        return 0.001;
      }
    },
    enumerable: true
  });
  //
  Object.defineProperty(p, 'dy', {
    get: function () {
      if (this.m !== 0) {
        return this.vy / this.m;
      } else {
        return 0.001;
      }
    },
    enumerable: true
  });
  /**
   * angle (degrees)
   * finding the vx and vy properties with a vector's angle:
   * vx = magnitude * Math.cos(angle);
   * vy = magnitude * Math.sin(angle);
   */
  Object.defineProperty(p, 'radians', {
    get: function () {
      return ATAN2(this.vy, this.vx);
    },
    enumerable: true
  });
  /**
   * angle (degrees)
   * finding the vx and vy properties with a vector's angle:
   * vx = magnitude * Math.cos(angle);
   * vy = magnitude * Math.sin(angle);
   */
  Object.defineProperty(p, 'angle', {
    get: function () {
      return this.radians * 180 / PI;
    },
    enumerable: true
  });

  /**
   * Initialization method. Can also be used to reinitialize the instance.
   * @method update
   * @param {Number} [startX=0]
   * @param {Number} [startY=0]
   * @param {Number} [endX=0]
   * @param {Number} [endY=0]
   * @param {Number} [newVX=0]
   * @param {Number} [newVY=0]
   * @return {Vector} This instance. Useful for chaining method calls.
   */
  p.update = function (startX, startY, endX, endY, newVX, newVY) {
    startX = startX || 0;
    startY = startY || 0;
    endX = endX || 0;
    endY = endY || 0;
    newVX = newVX || 0;
    newVY = newVY || 0;
    //console.log("update : ", startX, startY, endX, endY, newVX, newVY);
    if (newVX === 0 && newVY === 0) {
      this.privateA.x = startX;
      this.privateA.y = startY;
      this.privateB.x = endX;
      this.privateB.y = endY;
    } else {
      this.privateVX = newVX;
      this.privateVY = newVY;
    }
    return this;
  };

  p.toString = function () {
    var timestamp = ((Date.now() - START_TIME) / 1000).toFixed(4);
    return "[ " + timestamp + " ] " + " [ a.x: " + this.a.x.toFixed(1) + ", a.y: " + this.a.y.toFixed(1) + ", b.x: " + this.b.x.toFixed(1) + ", b.y: " + this.b.y.toFixed(1) + ", vx: " + this.vx.toFixed(3) + ", vy: " + this.vy.toFixed(3) + ", m: " + this.m.toFixed(3) + ", dx: " + this.dx.toFixed(3) + ", dy: " + this.dy.toFixed(3) + " ]";
  };

  /**
   * Returns a clone of the Vector instance.
   * @method clone
   * @return {Vector} a clone of the Vector instance.
   **/
  p.clone = function () {
    return new Vector(this.a.x, this.a.y, this.b.x, this.b.y);
  };

  p.getMidVector = function () {
    if (this.a.x === 0 && this.a.y === 0 && this.b.x === 0 && this.b.y === 0) {
      return null;
    }
    var d = Vector.distance(this.a.x, this.a.y, this.b.x, this.b.y) / 2,
      nvx = this.a.x + this.dx * d,
      nvy = this.a.y + this.dy * d;
    return new Vector(nvx, nvy, this.b.x, this.b.y);
  };

  p.normalize = function () {
    return this.update(0, 0, 0, 0, this.dx, this.dy);
  };

  /**
   * angle (degrees)
   * finding the vx and vy properties with a vector's angle:
   * vx = magnitude * Math.cos(angle);
   * vy = magnitude * Math.sin(angle);
   */
  Vector.getVectorFromAngle = function (angle, magnitude) {
    var v = new Vector(),
      m = magnitude || 1.0;
    return v.update(0, 0, 0, 0, m * COS(angle), m * SIN(angle));
  };

  /**
   * Find the distance between two points
   * @param   {number} ax start x
   * @param   {number} ay start y
   * @param   {number} bx end x
   * @param   {number} by end y
   * @returns {number} The new vector's magnitude
   */
  Vector.distance = function (ax, ay, bx, by) {
    var v = new Vector(ax, ay, bx, by);
    return v.m;
  };

  /**
   * Finding the dot product:
   * the first vector is multiplied by the second vector's normalized unit vector.
   * @param   {object} v1 The first vector
   * @param   {object} v2 The second vector
   * @returns {number} A positive number if the vectors are pointing in the same direction.
   */
  Vector.dotProduct = function (v1, v2) {
    return v1.vx * v2.dx + v1.vy * v2.dy;
  };
  // and this is non scaled version
  Vector.dotProduct2 = function (v1, v2) {
    return v1.vx * v2.vx + v1.vy * v2.vy;
  };

  /**
   * The same as finding the dot product, except instead of using v1 we use v1's normal.
   * @param   {object} v1 The first vector
   * @param   {object} v2 The second vector
   * @returns {number} The perpendicular dot product
   */
  Vector.perpProduct = function (v1, v2) {
    var perpProduct = v1.ln.vx * v2.dx + v1.ln.vy * v2.dy;
    //You can calculate the same result using
    //the vectors' vx and vy like this:
    //var perpProduct = v1.vx * v2.vy - v1.vy * v2.vx;
    if (perpProduct !== 0) {
      return perpProduct;
    }
    return 1;
  };

  /**
   * Find the ratio between the perpProducts of v1 and v2
   * This helps to find the intersection point
   * @param   {object} v1 The first vector
   * @param   {object} v2 The second vector
   * @returns {number} ratio
   */
  Vector.ratio = function (v1, v2) {
    var v3, ratio;
    //Make sure that the vectors aren't parallel
    if ((v1.dx === v2.dx && v1.dy === v2.dy) || (v1.dx === -v2.dx && v1.dy === -v2.dy)) {
      return 1;
    }
    //Make sure that neither vector has a length of zero
    if ((v1.m === 0 || v2.m === 0)) {
      return 1;
    }
    //Create a third vector between
    //the start points of vectors one and two
    //to help find the interection point
    v3 = new Vector();
    v3.update(v1.a.x, v1.a.y, v2.a.x, v2.a.y);

    return Vector.perpProduct(v3, v2) / Vector.perpProduct(v1, v2);
  };

  /**
   * Calculate a collision force vector
   * @param   {object} v1 The first vector
   * @param   {object} v2 The second vector
   * @returns {object} The new collision vector
   */
  Vector.collisionForce = function (v1, v2) {
    var t = Vector.ratio(v1, v2),
      intersectionX = v1.a.x + v1.vx * t,
      intersectionY = v1.a.y + v1.vy * t,
      //Calculate the force of the impact (collision vector)
      collisionForceVx = v1.a.x + v1.vx - intersectionX,
      collisionForceVy = v1.a.y + v1.vy - intersectionY,
      //Create a collision force Vector to return to the caller
      collisionVector = new Vector(0, 0, 0, 0, collisionForceVx, collisionForceVy);
    return collisionVector;
  };

  /**
   * Calculate a projection
   * @param   {object} v1 The first vector
   * @param   {object} v2 The second vector
   * @returns {object} The projection vector
   */
  Vector.project = function (v1, v2) {
    //Find the dot product between v1 and v2
    var dp1 = Vector.dotProduct(v1, v2),
      //Find the projection of v1 onto v2
      vx = dp1 * v2.dx,
      vy = dp1 * v2.dy,
      //Add start and end points, if they exist
      aX = 0,
      aY = 0,
      bX = 0,
      bY = 0,
      //Create a projection Vector to return to the caller
      projectionVector = new Vector();

    if (v2.a.x !== 0 && v2.a.y !== 0) {
      aX = v2.a.x;
      aY = v2.a.y;
      bX = v2.a.x + vx;
      bY = v2.a.y + vy;
      projectionVector.update(aX, aY, bX, bY);
    } else {
      projectionVector.update(0, 0, 0, 0, vx, vy);
    }
    return projectionVector;
  };

  Vector.bounce = function (v1, v2) {
    //Find the projection onto v2
    var p1 = Vector.project(v1, v2),
      //Find the projection onto v2's normal
      p2 = Vector.project(v1, v2.ln),
      //Calculate the bounce vector by adding up the projections
      //and reversing the projection onto the normal
      bounceVX = p1.vx + (p2.vx * -1),
      bounceVY = p1.vy + (p2.vy * -1),
      //Create a bounce VectorModel to return to the caller
      bounceVector = new Vector(0, 0, 0, 0, bounceVX, bounceVY);
    // bounce2
    //bounceVX = p1.vx + p2.vx;
    //bounceVY = p1.vy + p2.vy;
    return bounceVector;
  };

  Vector.findIntersection = function (v1, v2) {
    //Find out if the vectors are paralell
    if ((v1.dx === v2.dx && v1.dy === v2.dy) || (v1.dx === -v2.dx && v1.dy === -v2.dy)) {
      return 1;
    } else {
      //Create two new vectors between the
      //start points of vectors 1 and 2
      var v3 = new Vector(v1.a.x, v1.a.y, v2.a.x, v2.a.y),
        v4 = new Vector(v2.a.x, v2.a.y, v1.a.x, v1.a.y),
        t1 = Vector.perpProduct(v3, v2) / Vector.perpProduct(v1, v2),
        t2 = Vector.perpProduct(v4, v1) / Vector.perpProduct(v2, v1);
      if (t1 > 0 && t1 <= 1 && t2 > 0 && t2 <= 1) {
        return t1;
      } else {
        return 1;
      }
    }
  };

  /*function mixinVector(obj) {

  }*/

  // save Vector in global namespace
  lib.Vector = Vector;

}());

/**
 * pointerEvents
 * Author  : Joerg Pfeifer - pfeifer@create4web.de
 * Created : 27.12.2020
 * Modified:
 */
(function ($) {

  'use strict';

  var pointerEvents = {
      vectorPos: new lib.Vector(),
      pointerPos: {
        distance: 0,
        origX: 0,
        origY: 0,
        x: 0,
        y: 0
      },
      lockAxis: false,
      direction: '',
      EVENT_DOWN: "mousedown",
      EVENT_UP: "mouseup",
      EVENT_MOVE: "mousemove",
      minDistanceToDrag: 2,
      minDistanceToSwipe: 40,
      // will be overwritten by 'setOSEventNames'
      isMobile: true,
    },
    handlers = [],
    UID = 0,
    timeoutID = null,
    getUniqueID = function () {
      return UID++;
    },
    getHandler = function ($element) {
      var i, l = handlers.length,
        uid = $element.data('uid');
      //console.log("# pointerEvents getHandler ", "$element", $element, "uid", uid);
      // early out
      if (typeof uid === 'undefined') {
        return null;
      }
      for (i = 0; i < l; i++) {
        //console.log("# pointerEvents getHandler ", "handlers[", i, "]", handlers[i]);
        //console.log("# pointerEvents getHandler ", "(handlers[", i, "].elem == $element)", (handlers[i].elem == $element));
        if (handlers[i].uid === uid) {
          return handlers[i];
        }
      }
      return null;
    },
    setOSEventNames = function () {
      var flag = 0;
      pointerEvents.isMobile = true;
      try {
        document.createEvent("TouchEvent");
        flag = 1;
      } catch (ed) {
        if (window.navigator.pointerEnabled) {
          flag = 2;
        } else if (window.navigator.msPointerEnabled) {
          flag = 3;
        }
      }
      switch (flag) {
        case 0:
          pointerEvents.EVENT_DOWN = 'mousedown';
          pointerEvents.EVENT_UP = 'mouseup';
          pointerEvents.EVENT_MOVE = 'mousemove';
          break;
        case 1:
          pointerEvents.EVENT_DOWN = 'touchstart';
          pointerEvents.EVENT_UP = 'touchend';
          pointerEvents.EVENT_CANCEL = 'touchcancel';
          pointerEvents.EVENT_MOVE = 'touchmove';
          break;
        case 2:
          pointerEvents.EVENT_DOWN = 'pointerup';
          pointerEvents.EVENT_UP = 'pointerdown';
          pointerEvents.EVENT_MOVE = 'pointermove';
          break;
        case 3:
          pointerEvents.EVENT_DOWN = 'MSPointerDown';
          pointerEvents.EVENT_UP = 'MSPointerUp';
          pointerEvents.EVENT_MOVE = 'MSPointerMove';
          break;
      }
    },
    hasHandler = function ($element) {
      var i, l = handlers.length,
        uid = $element.data('uid');
      // early out
      if (typeof uid === 'undefined') {
        return false;
      }
      for (i = 0; i < l; i++) {
        if (handlers[i].uid === uid) {
          return true;
        }
      }
      return false;
    },
    handleDown = function (e) {
      //console.log("# pointerEvents handleDown ", "event", e);
      //if (e.preventDefault) { e.preventDefault(); }
      var pointerPos = pointerEvents.pointerPos;
      pointerPos.state = pointerEvents.EVENT_DOWN;
      pointerPos.origX = e.clientX || e.touches[0].clientX;
      pointerPos.origY = e.clientY || e.touches[0].clientY;
      pointerPos.x = pointerPos.origX;
      pointerPos.y = pointerPos.origY;
      pointerPos.distance = 0;
      pointerEvents.direction = null;
      pointerEvents.vectorPos.update(pointerPos.x, pointerPos.y, pointerPos.x, pointerPos.y);
      //console.log("# pointerEvents handleDown ", "pointerPos", pointerPos);
    },
    handleUp = function (e) {
      //console.log("# pointerEvents handleUp ", "event", e);
      if (e.preventDefault) {
        e.preventDefault();
      }
      var $target = $(e.currentTarget),
        callback = getHandler($target);
      pointerEvents.pointerPos.state = pointerEvents.EVENT_UP;
      /* console.log("# pointerEvents handleUp ", "e.currentTarget", e.currentTarget);
      console.log("# pointerEvents handleUp ", "$target", $target);
      console.log("# pointerEvents handleUp ", "callback", callback);
      console.log("# pointerEvents handleUp ", "pointerPos", JSON.stringify(pointerEvents.pointerPos)); */
      if (callback) {
        callback.func({
          type: pointerEvents.EVENT_UP
        });
      }
    },
    handleMove = function (e) {
      //console.log("# pointerEvents handleMove ", "event", e);
      var $target = $(e.currentTarget),
        callback = getHandler($target),
        pointerPos = pointerEvents.pointerPos,
        x = e.clientX || e.touches[0].clientX,
        y = e.clientY || e.touches[0].clientY,
        distance = pointerEvents.getDistance(pointerPos.origX, pointerPos.origY, x, y);
      //
      pointerPos.state = pointerEvents.EVENT_MOVE;
      if (x < pointerPos.origX) {
        pointerEvents.direction = 'left';
      } else if (x > pointerPos.origX) {
        pointerEvents.direction = 'right';
      }

      pointerPos.distance = distance;
      pointerPos.x = x;
      pointerPos.y = y;

      /* console.log("# pointerEvents handleMove ", "e.currentTarget", e.currentTarget);
      console.log("# pointerEvents handleMove ", "$target", $target);
      console.log("# pointerEvents handleMove ", "callback", callback);
      console.log("# pointerEvents handleMove ", "pointerPos", JSON.stringify(pointerEvents.pointerPos)); */
      if (callback) {
        callback.func({
          type: 'move',
          id: $target.data('uid'),
          pointer: {
            event: e,
            direction: pointerEvents.direction,
            position: JSON.parse(JSON.stringify(pointerEvents.pointerPos))
          }
        });
      }
    },
    handleSwipe = function (e) {
      //console.log("# pointerEvents handleSwipe ", "event", e);
      var $target, callback, pointerPos = pointerEvents.pointerPos;
      //console.log("# pointerEvents handleSwipe ", "pointerPos", pointerPos);
      // only allow swipe if distance greater than 'minDistanceToSwipe'
      if (pointerPos.distance > pointerEvents.minDistanceToSwipe) {
        $target = $(e.currentTarget);
        callback = getHandler($target);
        //console.log("# pointerEvents handleSwipe ", "$target", $target);
        //console.log("# pointerEvents handleSwipe ", "callback", callback);
        if (callback) {
          setTimeout(function () {
            callback.func({
              type: 'change',
              id: $target.data('uid'),
              pointer: {
                event: e,
                direction: pointerEvents.direction,
                position: JSON.parse(JSON.stringify(pointerPos))
              }
            });
          });
        }
      }
    },
    handleDrag = function (e) {
      //console.log("# pointerEvents handleDrag ", "event", e);
      if (e.preventDefault) {
        e.preventDefault();
      }
      var $target, hasChanged, distance, vx, vy,
        callback = null,
        direction = '',
        pointerPos = pointerEvents.pointerPos,
        x = e.clientX || e.touches[0].clientX,
        y = e.clientY || e.touches[0].clientY,
        lastDistance = pointerPos.distance,
        lastDirection = pointerEvents.direction;
      //
      if (pointerEvents.lockAxis) {
        if (pointerEvents.lockAxis === 'x') {
          x = pointerPos.origX;
        } else if (pointerEvents.lockAxis === 'y') {
          y = pointerPos.origY;
        }
      }
      //
      pointerEvents.vectorPos.update(pointerPos.x, pointerPos.y, x, y);
      distance = pointerEvents.vectorPos.m;
      vx = pointerEvents.vectorPos.vx;
      vy = pointerEvents.vectorPos.vy;

      //console.log("#");
      //console.log("# pointerEvents handleDrag ", "distance", distance, "x:", x, "vx:", vx);
      //if (timeoutID) { clearTimeout(timeoutID); }
      // only allow scratch if move is
      if (Math.abs(distance) > pointerEvents.minDistanceToDrag) {
        if (Math.abs(vx) > Math.abs(vy)) {
          if (vx < 0) {
            direction = 'left';
          } else if (vx > 0) {
            direction = 'right';
          }
        } else if (Math.abs(vx) < Math.abs(vy)) {
          if (vy < 0) {
            direction = 'up';
          } else if (vy > 0) {
            direction = 'down';
          }
        }
        hasChanged = (lastDirection !== '' && direction !== '' && lastDirection !== direction) || (typeof lastDirection === 'undefined');
        pointerPos.x = x;
        pointerPos.y = y;
        pointerPos.distance = distance;
        //
        $target = $(e.currentTarget);
        callback = getHandler($target);
        //console.log("# pointerEvents handleDrag ", "$target", $target);
        //console.log("# pointerEvents handleDrag ", "callback", callback);
        if (hasChanged) {
          pointerEvents.direction = direction;
          //console.log("# pointerEvents handleDrag ", "e.currentTarget", e.currentTarget);
          if (callback) {
            callback.func({
              type: 'change',
              touches: e.touches
            });
          }
        }
        if (callback) {
          callback.func({
            type: 'drag',
            touches: e.touches
          });
        }
        /*timeoutID = setTimeout(function () {
            callback.func({ type: 'dragend', touches: e.touches });
        }, 25);*/
      }

    },
    handleResize = function () {
      setOSEventNames();
    },
    preventDefault = function (e) {
      //if (e.touches && e.touches.length > 1) { return true; }
      //e.cancelable &&
      if (e.cancelable && e.preventDefault) {
        e.preventDefault();
      }
      return false;
    },
    removeHandler = function ($element) {
      var i, l = handlers.length,
        uid = $element.data('uid');
      //console.log("# pointerEvents removeHandler ", "$element", $element, "uid", uid);
      // early out
      if (!uid) {
        return false;
      }
      for (i = 0; i < l; i++) {
        //console.log("# pointerEvents removeHandler ", "handlers[", i, "]", handlers[i]);
        //console.log("# pointerEvents removeHandler ", "(handlers[", i, "].elem == $element)", (handlers[i].elem == $element));
        if (handlers[i].uid === uid) {
          handlers.splice(i, 1);
          return true;
        }
      }
    };

  //
  // init event names
  setOSEventNames();
  // register for resize so we are able to change event names
  //window.addEventListener('resize', handleResize);
  //console.log("# pointerEvents setOSEventNames ", "pointerEvents.EVENT_DOWN", pointerEvents.EVENT_DOWN);
  //console.log("# pointerEvents setOSEventNames ", "pointerEvents.EVENT_UP", pointerEvents.EVENT_UP);
  //console.log("# pointerEvents setOSEventNames ", "pointerEvents.EVENT_MOVE", pointerEvents.EVENT_MOVE);

  //
  pointerEvents.getDistance = function (ax, ay, bx, by) {
    var vx = bx - ax,
      vy = by - ay;
    if (vx !== 0 || vy !== 0) {
      return Math.sqrt(vx * vx + vy * vy);
    }
    return 0.001;
  };

  pointerEvents.up = function ($element, callback) {
    var uid = $element.data('uid');
    //console.log("+ pointerEvents up ", "uid", uid, "$element", $element, "uid", uid);
    if (!uid || !hasHandler($element)) {
      $element.on(pointerEvents.EVENT_UP, handleUp);
      uid = (!uid) ? getUniqueID() : uid;
      $element.data('uid', uid);
      //console.log("+ pointerEvents up ", "uid", uid, "$element", $element, "$element.data('uid')", $element.data('uid'));
      handlers.push({
        uid: uid,
        $elem: $element,
        func: callback
      });
    }
  };

  pointerEvents.disableScroll = function () {
    document.addEventListener(pointerEvents.EVENT_MOVE, preventDefault, {
      passive: false
    });
  };

  pointerEvents.enableScroll = function () {
    document.removeEventListener(pointerEvents.EVENT_MOVE, preventDefault, {
      passive: false
    });
  };

  pointerEvents.onSwipe = function ($element, callback) {
    var uid = $element.data('uid');
    //console.log("+ pointerEvents onSwipe ", "uid", uid, "eventDown", eventDown, "eventMove", eventMove, "eventUp", eventUp);
    if (!uid || !hasHandler($element)) {
      $element.on(pointerEvents.EVENT_DOWN + '.swipe', function (e) {
        //pointerEvents.disableScroll();
        handleDown(e);
      });
      $element.on(pointerEvents.EVENT_MOVE + '.swipe', handleMove);
      $element.on(pointerEvents.EVENT_UP + '.swipe', function (e) {
        handleSwipe(e);
        //pointerEvents.enableScroll();
      });
      uid = (!uid) ? getUniqueID() : uid;
      $element.data('uid', uid);
      //console.log("+ pointerEvents onSwipe ", "uid", uid, "$element", $element, "$element.data('uid')", $element.data('uid'));
      handlers.push({
        uid: uid,
        $elem: $element,
        func: callback
      });
    }
  };

  pointerEvents.offSwipe = function ($element) {
    $element.off(pointerEvents.EVENT_DOWN + '.swipe');
    $element.off(pointerEvents.EVENT_MOVE + '.swipe');
    $element.off(pointerEvents.EVENT_UP + '.swipe');
    removeHandler($element);
  };

  pointerEvents.onDrag = function ($element, callback) {
    var uid = $element.data('uid'),
      $parent = $('#ground-move-dummy');
    if (!uid || !hasHandler($element)) {
      pointerEvents.direction = undefined;
      /* $(document).on('touchstart touchmove touchend', function(e) {
          // Example of a parentSelector
          // var parentSelector = '#parentElement';
          if ($(e.target).closest($parent).length) {
              e.preventDefault();
          }
      }); */
      //
      $element.on(pointerEvents.EVENT_DOWN + '.drag', handleDown);
      $element.on(pointerEvents.EVENT_MOVE + '.drag', function (e) {
        //console.log("+ pointerEvents onDrag ", "uid", uid, "$element", $element, "pointerEvents.pointerPos.state", pointerEvents.pointerPos.state);
        if (pointerEvents.pointerPos.state === pointerEvents.EVENT_DOWN) {
          handleDrag(e);
        }
      });
      if (pointerEvents.EVENT_CANCEL) {
        $element.on(pointerEvents.EVENT_CANCEL + '.drag', handleUp);
      }
      $element.on(pointerEvents.EVENT_UP + '.drag', handleUp);
      uid = (!uid) ? getUniqueID() : uid;
      $element.data('uid', uid);
      //console.log("+ pointerEvents onDrag ", "uid", uid, "$element", $element, "$element.data('uid')", $element.data('uid'));
      handlers.push({
        uid: uid,
        $elem: $element,
        func: callback
      });
    }
  };

  pointerEvents.offDrag = function ($element) {
    $element.off(pointerEvents.EVENT_DOWN + '.drag');
    $element.off(pointerEvents.EVENT_MOVE + '.drag');
    $element.off(pointerEvents.EVENT_UP + '.drag');
    //document.body.removeEventListener(pointerEvents.EVENT_UP, handleUp);
    removeHandler($element);
  };

  lib.pointerEvents = pointerEvents;

}(jQuery));

/**
 * GameModel
 *
 * Author  : Joerg Pfeifer - pfeifer@create4web.de
 * Created : 21.04.2020
 * Modified: 13.01.2021
 */
(function () {

  'use strict';

  if (!window.lib) {
    window.lib = {};
  }

  // save shortcut to prototype
  var START_TIME = Date.now(),
    SQRT = Math.sqrt,
    ATAN2 = Math.atan2,
    SIN = Math.sin,
    COS = Math.cos,
    PI = Math.PI,
    mathAbs = Math.abs,
    mathMin = Math.min,
    p;

  /**
   * Verlet Integration
   * @returns {object} new GameModel instance
   */
  function GameModel(options) {
    // mixin EventDispatcher
    window.lib.EventDispatcher.init(this);
    //
    this.acc = [{
      x: 0,
      y: 0,
      z: 0
    }];
    this.accg = [{
      x: 0,
      y: 0,
      z: 0
    }];
    this.rota = [{
      alpha: 0,
      beta: 0,
      gamma: 0
    }];
    this.levels = (options && options.levels) ? options.levels : this.levels;
    this.sounds = (options && options.sounds) ? options.sounds : this.sounds;
    this.soundsJS = (options && options.soundsJS) ? options.soundsJS : this.soundsJS;
    this.collectedItems = (options && options.collectedItems) ? options.collectedItems : this.collectedItems;
    this.currentLevel = (options && options.currentLevel) ? options.currentLevel : this.currentLevel;
    this.isSoundOn = (options && typeof options.isSoundOn === 'boolean') ? options.isSoundOn : this.isSoundOn;
    this.levelHeight = 1920;
    this.playerModus = GameModel.PLAYER_MODUS_NORMAL;
    this.momentaryDirection = '';
    this.loop = 0;
    this.playerSpeedX = 2.5;
    this.score = (options && options.score) ? options.score : this.score;
    this.nickname = (options && options.nickname) ? options.nickname : this.nickname;
    this.life = (options && options.life) ? options.life : this.life;
    this.BESERK_TIME = (options && options.BESERK_TIME) ? options.BESERK_TIME : this.BESERK_TIME;
    this.OFFSET_TRAIN = (options && options.OFFSET_TRAIN) ? options.OFFSET_TRAIN : this.OFFSET_TRAIN;
    this.MOVE_SPEED_X = (options && options.MOVE_SPEED_X) ? options.MOVE_SPEED_X : this.MOVE_SPEED_X;
    this.DRAG_SPEED_X = (options && options.DRAG_SPEED_X) ? options.DRAG_SPEED_X : this.DRAG_SPEED_X;
    this.SCROLL_SPEED_Y = (options && options.SCROLL_SPEED_Y) ? options.SCROLL_SPEED_Y : this.SCROLL_SPEED_Y;
    this.SCROLL_SPEED_Y_MAX = (options && options.SCROLL_SPEED_Y_MAX) ? options.SCROLL_SPEED_Y_MAX : this.SCROLL_SPEED_Y_MAX;
    this.SCROLL_SPEED_ACC = (options && options.SCROLL_SPEED_ACC) ? options.SCROLL_SPEED_ACC : this.SCROLL_SPEED_ACC;
    this.SCROLL_SPEED_ACCELERATION = (options && options.SCROLL_SPEED_ACCELERATION) ? options.SCROLL_SPEED_ACCELERATION : this.SCROLL_SPEED_ACCELERATION;
    this.FRICTION_MAIN = (options && options.FRICTION_MAIN) ? options.FRICTION_MAIN : this.FRICTION_MAIN;
    this.FRICTION_KEY = (options && options.FRICTION_KEY) ? options.FRICTION_KEY : this.FRICTION_KEY;
    this.FRICTION_DEVICE = (options && options.FRICTION_DEVICE) ? options.FRICTION_DEVICE : this.FRICTION_DEVICE;
    this.ACCELERATION_KEY = (options && options.ACCELERATION_KEY) ? options.ACCELERATION_KEY : this.ACCELERATION_KEY;
    this.ACCELERATION_DEVICE = (options && options.ACCELERATION_DEVICE) ? options.ACCELERATION_DEVICE : this.ACCELERATION_DEVICE;
    this.scrollSpeedY = this.SCROLL_SPEED_Y;
    this.rectStage = new window.lib.Rectangle();
    this.rectPlayer = new window.lib.Rectangle();
    this.rectPlayerStart = new window.lib.Rectangle();
    this.rectPlayerMid = new window.lib.Rectangle();
    this.rectPlayerEnd = new window.lib.Rectangle();
  }

  // save shortcut to prototype
  p = GameModel.prototype;
  p.constructor = GameModel;

  GameModel.PLAYER_MODUS_NORMAL = 'normal';
  GameModel.PLAYER_MODUS_BESERK = 'beserk';

  // INTRO | LOAD | START | RUN | DEAD | AGAIN | FORM | HIGHSCORE |
  GameModel.STATE_INTRO = 'intro';
  GameModel.STATE_LOAD = 'load';
  GameModel.STATE_START = 'start';
  GameModel.STATE_PAUSE = 'pause';
  GameModel.STATE_RUN = 'run';
  GameModel.STATE_DEAD = 'dead';
  GameModel.STATE_AGAIN = 'again';
  GameModel.STATE_FORM = 'form';
  GameModel.STATE_HIGHSCORE = 'highscore';

  GameModel.lastTime = 0;
  GameModel.fps = 50;
  GameModel.MSPF = 1000 / GameModel.fps;
  GameModel.timeOutArr = [];
  //time based
  //timeNow = Date.now() - GameModel.lastTime,
  //this.scrollSpeedY = this.SCROLL_SPEED_Y * timeNow / GameModel.MSPF,
  //(end - start) / 3 | ((this.moveSpeedX * delta) - tempX) / 3;
  //add to last time
  //GameModel.lastTime += timeNow;
  //GameModel.timeOutArr.push(this.scrollSpeedY);

  //Global friction
  p.BESERK_TIME = 5;
  p.OFFSET_TRAIN = 5;
  p.FRICTION_MAIN = 0.96;
  p.FRICTION_KEY = 0.975;
  p.FRICTION_DEVICE = 0.975;
  p.MOVE_SPEED_X = 5;
  p.DRAG_SPEED_X = 5;
  p.SCROLL_SPEED_Y = 5;
  p.SCROLL_SPEED_Y_MAX = 7.75;
  p.SCROLL_SPEED_ACC = 0.1;
  p.SCROLL_SPEED_ACCELERATION = 0.001;
  p.ACCELERATION_KEY = 0.2;
  p.ACCELERATION_DEVICE = 0.2;

  p.x = 0;
  p.y = 0;
  p.rotationValue = 0;
  p.moveSpeedX = 0;
  p.moveX = 0;
  p.playerSpeedX = 2.5;
  p.scrollSpeedY = 0;
  p.acceleration = 0;
  p.friction = 0;
  p.direction = 0;
  p.playerStageY = 0;
  p.prevX = 0;
  p.prevY = 0;
  p.factorScale = 1;
  /* p.rectStage = new window.lib.Rectangle();
  p.rectPlayer = new window.lib.Rectangle();
  p.rectPlayerStart = new window.lib.Rectangle();
  p.rectPlayerMid = new window.lib.Rectangle();
  p.rectPlayerEnd = new window.lib.Rectangle(); */
  p.levels = [];
  p.sounds = [];
  p.soundsJS = [];
  p.collectedItems = [];
  p.currentLevel = 0;
  p.state = GameModel.STATE_INTRO;
  p.score = 0;
  p.life = 3;
  p.loop = 0;
  p.nickname = '';
  // device motion
  p.average = 10;
  p.active = true;
  p.isSoundOn = false;

  // velocity -> vx and vy properties
  Object.defineProperty(p, 'vx', {
    get: function () {
      return this.x - this.prevX;
    },
    set: function (val) {
      this.prevX = this.x - val;
    },
    enumerable: true
  });
  Object.defineProperty(p, 'vy', {
    get: function () {
      return this.y - this.prevY;
    },
    set: function (val) {
      this.prevY = this.y - val;
      //console.log("GameModel set vy", "val:", val, "prevY:", this.prevY, "y:", this.y);
    },
    enumerable: true
  });
  //magnitude (length)
  Object.defineProperty(p, 'm', {
    get: function () {
      if (this.vx !== 0 || this.vy !== 0) {
        return SQRT(this.vx * this.vx + this.vy * this.vy);
      } else {
        return 0.001;
      }
    },
    enumerable: true
  });
  /**
   * angle (degrees)
   * finding the vx and vy properties with a vector's angle:
   * vx = magnitude * COS(angle);
   * vy = magnitude * SIN(angle);
   */
  Object.defineProperty(p, 'angle', {
    get: function () {
      return this.rotationValue * (PI / 180);
    },
    enumerable: true
  });

  //
  p.getHighestPeak = function (arr, key, lastOut) {
    if (lastOut) {
      return arr[arr.length - 1][key];
    }
    var i, minus, l = arr.length,
      values = [];
    // make array with values of props
    for (i = 0; i < l; i++) {
      values.push(arr[i][key]);
    }
    //
    minus = (values[l - 1] < 0);
    return minus ? mathMin.apply(null, values) : Math.max.apply(null, values);
  };
  p.setAcc = function (acceleration) {
    var acc = this.acc;
    acc.push(acceleration);
    if (acc.length > this.average) {
      acc.shift();
    }
  };
  p.setAccg = function (accelerationIncludingGravity) {
    var accg = this.accg;
    accg.push(accelerationIncludingGravity);
    if (accg.length > this.average) {
      accg.shift();
    }
  };
  p.setRota = function (rotationRate) {
    var rota = this.rota;
    rota.push(rotationRate);
    if (rota.length > this.average) {
      rota.shift();
    }
  };

  p.setX = function (val) {
    this.prevX = val - this.vx;
    this.x = val;
    this.moveX = val;
    this.rectPlayer.x = val;
    this.setRectPlayer(val, mathAbs(this.y - this.playerStageY));
  };

  p.setY = function (val) {
    this.prevY = val - this.vy;
    this.y = val;
    this.rectPlayer.y = mathAbs(val - this.playerStageY);
    this.setRectPlayer(this.x, mathAbs(val - this.playerStageY));
  };

  p.setGlobals = function (obj) {
    var key, val;
    for (key in obj) {
      if (obj.hasOwnProperty(key) && this.hasOwnProperty(key)) {
        val = obj[key];
        this[key] = val;
        //console.log("setGlobals", "key:", key, "val:", val);
      }
    }
  };

  p.setLife = function (value) {
    var life = this.life + value;
    if (life >= 0) {
      this.life = life;
    }
  };

  p.getNextLevelIndexFrom = function (index) {
    return (index + 1 < this.levels.length) ? index + 1 : 0;
  };

  p.getNextLevelIndex = function () {
    return this.getNextLevelIndexFrom(this.currentLevel);
  };

  p.checkGroundBoundaries = function () {
    /*console.log("checkGroundBoundaries", 'rectStage:', rectStage);
    console.log("checkGroundBoundaries", 'rectPlayer:', rectPlayer);*/
    //change current level index after reaching scrollTo (will change)
    if (this.y >= this.rectStage.height) {
      //nextLevel();
      return false;
    }
    return true;
  };

  p.checkPlayerBoundaries = function () {
    var rectStage = this.rectStage,
      offset = this.width / 2;
    //console.log("checkPlayerBoundaries", 'rectStage:', rectStage);
    if (this.x < offset) {
      this.x = offset;
    } else if (this.x > rectStage.width - this.width - offset) {
      this.x = rectStage.width - this.width - offset;
    }
    //console.log("checkPlayerBoundaries", 'rectPlayer:', rectPlayer);
  };

  //check player rects inside
  p.playerWallCollision = function (wall, intersection, type) {
    //collision happens on the *smallest* amount
    if (intersection.width <= intersection.height) {
      //left-side-hit
      if (wall.x < intersection.x) {
        //console.log("checkPlayerWallCollision", 'happens on x axis left');
        this.x = intersection.x + intersection.width;
      } else {
        //console.log("checkPlayerWallCollision", 'happens on x axis right');
        this.x -= intersection.width;
      }
    } else {
      this.y -= intersection.height;
    }
    if (wall.name === 'stapler-0') {
      wall.tl.pause();
      this.currentWall = wall;
    }
    return type;
  };

  p.checkPlayerWallCollision = function () {
    var i, wall, intersection, interStart, interMid, interEnd,
      level = this.levels[this.currentLevel],
      walls = level.walls,
      l = walls.length,
      rectPlayer = this.rectPlayer,
      rectPlayerStart = this.rectPlayerStart,
      rectPlayerMid = this.rectPlayerMid,
      rectPlayerEnd = this.rectPlayerEnd;

    //console.log("checkPlayerWallCollision", "x", this.x, "y", this.y, "direction", this.direction);
    /*console.log("checkPlayerWallCollision", "rectPlayer", rectPlayer);
    console.log("checkPlayerWallCollision", "rectPlayerStart", rectPlayerStart);
    console.log("checkPlayerWallCollision", "rectPlayerMid", rectPlayerMid);
    console.log("checkPlayerWallCollision", "rectPlayerEnd", rectPlayerEnd);*/
    for (i = 0; i < l; i++) {
      wall = walls[i];
      intersection = rectPlayer.getIntersection(wall);

      //if intersection happens we first check rects inside player
      if (intersection) {
        /*console.log("checkPlayerWallCollision", 'rectPlayer:', rectPlayer, 'wall:', wall);
        console.log("checkPlayerWallCollision", 'rectPlayerStart:', rectPlayerStart);
        console.log("checkPlayerWallCollision", 'rectPlayerMid:', rectPlayerMid);
        console.log("checkPlayerWallCollision", 'rectPlayerEnd:', rectPlayerEnd);*/
        //update rectangles inside player
        interStart = rectPlayerStart.getIntersection(wall);
        if (interStart) {
          //console.log("checkPlayerWallCollision", 'rectPlayer:', rectPlayer, 'interStart:', interStart);
          return this.playerWallCollision(wall, interStart, 'front');
        }
        interMid = rectPlayerMid.getIntersection(wall);
        if (interMid) {
          //console.log("checkPlayerWallCollision", 'rectPlayer:', rectPlayer, 'interMid:', interMid);
          return this.playerWallCollision(wall, interMid, 'mid');
        }
        interEnd = rectPlayerEnd.getIntersection(wall);
        if (interEnd) {
          //console.log("checkPlayerWallCollision", 'rectPlayer:', rectPlayer, 'interEnd:', interEnd);
          return this.playerWallCollision(wall, interEnd, 'end');
        }
        //this.playerWallCollision(wall, intersection);
        //console.log("checkPlayerWallCollision", 'rectPlayer:', rectPlayer, 'wall:', wall, 'intersection:', intersection);
      }
    }
    return '';
  };

  p.toString = function () {
    var timestamp = ((Date.now() - START_TIME) / 1000).toFixed(4);
    return "[ " + timestamp + " ] " + " [ x: " + this.x.toFixed(1) + ", y: " + this.y.toFixed(1) + ", rectPlayer.y: " + this.rectPlayer.y.toFixed(1) + ", life: " + this.life + ", score: " + this.score + " ]";
  };

  /**
   * Called by client application
   */
  p.update = function (delta) {};

  p.updateVerletKey = function (delta) {
    //console.log("update", "active:", this.active);
    var tempX = this.x,
      tempY = this.y;
    //moveSpeedX = this.moveSpeedX;
    //moveSpeedX = (this.moveSpeedX * delta);

    // 2. calculate player x
    //this.playerSpeedX += (moveSpeedX - this.playerSpeedX) * ((moveSpeedX !== 0) ? 0.25 : 0.75);
    /* if (moveSpeedX !== 0) {
        this.playerSpeedX += (moveSpeedX - this.playerSpeedX) * 0.25;
    } else {
        this.playerSpeedX = moveSpeedX;
    }
    this.x += this.playerSpeedX;
    */

    // 3. move
    //this.x += this.moveSpeedX;
    this.x += this.moveSpeedX * delta;
    //this.x += ((this.moveSpeedX * delta) - tempX) * 0.35;
    //this.x += (tempX - (this.moveSpeedX * delta)) / 3;
    //this.y += this.scrollSpeedY;
    // or time based
    this.y += this.scrollSpeedY * delta;

    // 4. previous position is used to calculate velocity
    this.prevX = tempX;
    this.prevY = tempY;

    // 5. calculate player rectangles
    this.setRectPlayer(this.x, mathAbs(this.y - this.playerStageY));
    //console.log("update", "x:", this.x, "y:", this.y);
    //console.log("update", "y:", this.y, "rectPlayer:", this.rectPlayer, "rectPlayerStart:", this.rectPlayerStart);
    //6. accelerate each step
    //this.scrollSpeedY += this.SCROLL_SPEED_ACCELERATION;
  };

  p.updateVerlet = function (delta) {
    var tempX = this.x,
      tempY = this.y;
    this.x += this.moveSpeedX * delta;
    this.y += this.scrollSpeedY * delta;
    //previous position is used to calculate velocity
    this.prevX = tempX;
    this.prevY = tempY;
    //calculate player rectangles
    this.setRectPlayer(this.x, mathAbs(this.y - this.playerStageY));
    //accelerate each step
    //this.scrollSpeedY += this.SCROLL_SPEED_ACCELERATION;
  };

  p.updateEuler = function (delta) {
    // 1. save previous values
    var tempX = this.x,
      tempY = this.y;
    // 2. calculate player and platform
    // 3. move
    //this.x = this.moveX;
    //this.x = this.moveX * delta;
    this.x += (this.moveX - this.prevX) * 0.075;
    this.y += this.scrollSpeedY * delta;
    // 4. previous position is used to calculate velocity
    this.prevX = tempX;
    this.prevY = tempY;
    // 5. calculate player rectangles
    this.setRectPlayer(this.x, mathAbs(this.y - this.playerStageY));
    //console.log("updateMobile", "x:", this.x, "delta:", delta);
    //6. accelerate each step
    //this.scrollSpeedY += this.SCROLL_SPEED_ACCELERATION;
  };

  p.setRectPlayer = function (x, y) {
    var offset = this.OFFSET_TRAIN;
    this.rectPlayer.x = x;
    this.rectPlayerStart.x = x;
    if (this.direction > 0) {
      //right
      this.rectPlayerMid.x = x - offset;
      this.rectPlayerEnd.x = this.rectPlayerMid.x;
    } else if (this.direction < 0) {
      //left
      this.rectPlayerMid.x = x + offset;
      this.rectPlayerEnd.x = this.rectPlayerMid.x;
    } else {
      //center (end - start) / 3
      this.rectPlayerMid.x += (x - this.rectPlayerMid.x) / 3;
      this.rectPlayerEnd.x = this.rectPlayerMid.x;
    }
    this.rectPlayer.y = y;
    this.rectPlayerStart.y = this.rectPlayer.y;
    this.rectPlayerMid.y = this.rectPlayer.y + this.rectPlayerStart.height;
    this.rectPlayerEnd.y = this.rectPlayerMid.y + this.rectPlayerMid.height;
  };

  /**
   * GroundModel extends GameModel
   * @param {object} options an optional option object
  function GameModel(options) {
      // call super constructor.
      GameModel.call(this);
  }
  // subclass extends superclass
  p = GroundModel.prototype = Object.create(GameModel.prototype);
  p.constructor = GroundModel; */

  // save GroundModel in global namespace
  // and leave abstract GameModel private
  //lib.GroundModel = GroundModel;
  lib.GameModel = GameModel;

}());

/**
 * GameController
 *
 * Author  : Joerg Pfeifer - pfeifer@create4web.de
 * Created : 22.04.2020
 * Modified:
 */
(function () {

  'use strict';

  var p,
    mathMin = Math.min,
    mathAbs = Math.abs;

  if (!window.lib) {
    window.lib = {};
  }

  /**
   * Abstract GameController prototype
   * @param {object} model A model for MVC
   */
  function GameController(name, model) {
    this.name = name;
    this.model = model;
    this.operatingSystem = GameController.getMobileOperatingSystem();
    // mixin EventDispatcher
    window.lib.EventDispatcher.init(this);
  }

  // save shortcut to prototype
  p = GameController.prototype;

  p.model = null;
  p.name = 'GameController';

  /**
   * Determine the mobile operating system.
   * This function returns one of 'iOS', 'Android', 'Windows Phone', or 'unknown'.
   *
   * @returns {String}
   */
  GameController.getMobileOperatingSystem = function () {

    var userAgent = navigator.userAgent || navigator.vendor || window.opera,
      getIOSVersion = function (ua) {
        var regexOS = /iPhone OS ([0-9]+)/,
          version = regexOS.exec(ua);
        //console.log(version);
        return (version && version.length > 1) ? parseInt(version[1]) : 'iOS';
      };
    GameController.flag = 0;
    //
    try {
      document.createEvent("TouchEvent");
      GameController.flag = 1;
    } catch (e) {
      if (window.navigator.pointerEnabled) {
        GameController.flag = 2;
      } else if (window.navigator.msPointerEnabled) {
        GameController.flag = 3;
      }
    }
    // Windows Phone must come first because its UA also contains "Android"
    if (/windows phone/i.test(userAgent)) {
      return "Windows Phone";
    }
    if (/android/i.test(userAgent)) {
      return "Android";
    }
    // iOS detection from: http://stackoverflow.com/a/9039885/177710
    if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {
      //console.log('getMobileOperatingSystem', 'userAgent:', userAgent);
      //$('#consolas-1').html('getMobileOperatingSystem' + '<br>userAgent:<br>' + userAgent);
      //Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1
      //Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1
      return getIOSVersion(userAgent);
    }
    //console.log('getMobileOperatingSystem', 'flag:', GameController.flag);
    if (GameController.flag === 0) {
      return "desktop";
    }
    if (GameController.flag === 1) {
      return "mobile";
    }
    return "unknown";
  };

  /**
   * KeyController keeps track of ground moving
   * @param {GameModel} model   The model
   */
  function KeyController(model) {
    // call super constructor.
    GameController.call(this, 'KeyController', model);
    // register keyboard events desktop
    document.addEventListener('keydown', this.handleKeyDown.bind(this));
    document.addEventListener('keyup', this.handleKeyUp.bind(this));
    this.active = true;
    this.isDown = false;
  }

  // subclass extends superclass
  p = KeyController.prototype = Object.create(GameController.prototype);
  p.constructor = KeyController;

  p.kill = function () {
    document.removeEventListener('keydown', this.handleKeyDown.bind(this));
    document.removeEventListener('keyup', this.handleKeyUp.bind(this));
  };

  p.setActive = function (active) {
    this.active = active;
  };

  p.handleKeyDown = function (e) {
    //console.log("Controller", "handleKeyDown", "e.code:", e.code);
    if (this.active && !this.isDown) {
      //if (this.active) {
      switch (e.code) {
        case 'ArrowLeft':
          this.model.direction = -1;
          this.model.moveSpeedX = -this.model.MOVE_SPEED_X;
          break;
        case 'ArrowRight':
          this.model.direction = 1;
          this.model.moveSpeedX = this.model.MOVE_SPEED_X;
          break;
      }
      //this.dispatchEvent({ type: "change", keydown: true, keyup: false, code: e.code, direction: this.model.direction });
    }
    this.isDown = true;
  };

  p.handleKeyUp = function (e) {
    this.isDown = false;
    this.model.moveSpeedX = 0;
    this.model.direction = 0;
    this.model.playerSpeedX = 1;
    //if (this.active) { this.dispatchEvent({ type: "change", keydown: false, keyup: true, code: e.code, direction: this.model.direction }); }
  };

  /**
   * KeyControllerGsap keeps track of ground moving
   * @param {GameModel} model   The model
   */
  function KeyControllerGsap(model) {
    // call super constructor.
    GameController.call(this, 'KeyControllerGsap', model);
    // register keyboard events desktop
    document.addEventListener('keydown', this.handleKeyDown.bind(this));
    document.addEventListener('keyup', this.handleKeyUp.bind(this));
    this.active = true;
    this.isDown = false;
    this.isRunning = false;
    this.speedX = 1;
    this.duration = 0.075;
  }

  // subclass extends superclass
  p = KeyControllerGsap.prototype = Object.create(GameController.prototype);
  p.constructor = KeyControllerGsap;

  p.kill = function () {
    document.removeEventListener('keydown', this.handleKeyDown.bind(this));
    document.removeEventListener('keyup', this.handleKeyUp.bind(this));
  };

  p.setActive = function (active) {
    this.active = active;
  };

  p.handleKeyDown = function (e) {
    //console.log("Controller", "handleKeyDown", "e.code:", e.code);
    var that = this;
    if (this.active) {
      switch (e.code) {
        case 'ArrowLeft':
          this.model.moveSpeedX = -this.model.MOVE_SPEED_X;
          this.model.direction = -1;
          break;
        case 'ArrowRight':
          this.model.moveSpeedX = this.model.MOVE_SPEED_X;
          this.model.direction = 1;
          break;
      }
      /* switch (e.code) {
      case 'ArrowLeft':
          this.model.direction = -1;
          if (!this.isDown) {
              this.isRunning = true;
              gsap.to(this, { speedX: this.model.MOVE_SPEED_X, onUpdate: function () {
                  that.model.moveSpeedX = -that.speedX;
              }, onComplete: function () {
                  that.isRunning = false;
              }, duration: this.duration });
          } else if (!this.isRunning) {
              this.model.moveSpeedX = -this.model.MOVE_SPEED_X;
          }
          break;
      case 'ArrowRight':
          this.model.direction = 1;
          if (!this.isDown) {
              this.isRunning = true;
              gsap.to(this, { speedX: this.model.MOVE_SPEED_X, onUpdate: function () {
                  that.model.moveSpeedX = that.speedX;
                  //console.log("Controller", "handleKeyDown", "moveSpeedX:", that.model.moveSpeedX);
              }, onComplete: function () {
                  that.isRunning = false;
              }, duration: this.duration });
          } else if (!this.isRunning) {
              this.model.moveSpeedX = this.model.MOVE_SPEED_X;
          }
          break;
      } */
      //this.dispatchEvent({ type: "change", keydown: true, keyup: false, code: e.code, direction: this.model.direction });
    }
    this.isDown = true;
  };

  p.handleKeyUp = function (e) {
    this.isDown = false;
    if (this.active) {
      switch (e.code) {
        case 'ArrowLeft':
        case 'ArrowRight':
          this.model.moveSpeedX = 0;
          this.model.direction = 0;
          this.model.playerSpeedX = 1;
          this.isRunning = false;
          this.speedX = 1;
          gsap.killTweensOf(this);
          break;
      }
      //this.dispatchEvent({ type: "change", keydown: false, keyup: true, code: e.code, direction: this.model.direction });
    }
  };

  /**
   * TouchControllerEuler keeps track of mouse/touch moving
   * @param {GameModel} model   The model
   * @param {jQuery} $target
   */
  function TouchControllerEuler(model, $target) {
    // call super constructor.
    GameController.call(this, 'TouchControllerEuler', model);
    this.$target = $target;
    this.moveObj = {
      x: this.model.moveX
    };
    lib.pointerEvents.onDrag($target, this.handleDrag.bind(this));
    //type: "x", bounds: { minX: -320, maxX: 320, minY: 0, maxY: 0 },
    this.active = true;
  }

  // subclass extends superclass
  p = TouchControllerEuler.prototype = Object.create(GameController.prototype);
  p.constructor = TouchControllerEuler;

  p.setActive = function (active) {
    this.active = active;
  };

  p.kill = function () {
    lib.pointerEvents.offDrag(this.$target);
  };

  p.handleDrag = function (event) {
    var that = this,
      minVX = 3,
      durationMove = 0.1,
      model = this.model,
      pEvents = lib.pointerEvents,
      playerHalfWidth = model.rectPlayer.width / 2,
      moveX = (pEvents.pointerPos.x - model.rectStage.x - playerHalfWidth) / model.factorScale,
      vx = pEvents.vectorPos.vx;
    //console.log("");
    //console.log("TouchControllerEuler", "handleDrag", "vx:", vx, "moveX:", moveX, "direction:", model.direction);
    //console.log("TouchControllerEuler", "handleDrag", "event:", event.type, "vectorPos:", pEvents.vectorPos, "touches:", event.touches);
    if (this.active) {
      //if (moveX < minX) { moveX = minX; }
      //if (moveX > maxX) { moveX = maxX; }
      if (vx < -minVX) {
        //left
        model.direction = -1;
      } else if (vx > minVX) {
        //right
        model.direction = 1;
      }
      gsap.to(this.moveObj, {
        x: moveX,
        onUpdate: function () {
          model.moveX = that.moveObj.x;
        },
        onComplete: function () {
          model.direction = 0;
          //$('#consolas-1').html('handleDrag' + '<br>pointerPos: ' + pEvents.pointerPos.x.toFixed(3) + '<br>moveX: ' + moveX.toFixed(3) + '<br>x: ' + model.x.toFixed(3) + '<br>factorScale: ' + model.factorScale.toFixed(3));
        },
        duration: durationMove,
        ease: 'power0'
      });
    }
    //$('#consolas-1').html('handleDrag' + '<br>pointerPos: ' + pEvents.pointerPos.x.toFixed(3) + '<br>moveX: ' + moveX.toFixed(3) + '<br>x: ' + model.x.toFixed(3) + '<br>factorScale: ' + model.factorScale.toFixed(3));
    //console.log("TouchControllerEuler", "handleDrag", "x:", model.x, "prevX:", model.prevX, "moveX:", moveX);
    //console.log("TouchControllerEuler", "handleDrag", "factorScale:", model.factorScale, "stage.x:", model.rectStage.x, "scaledStageWidth:", scaledStageWidth);
    if (event.type === pEvents.EVENT_UP) {
      model.direction = 0;
    }
    //this.dispatchEvent({ type: "change", keydown: true, keyup: false, code: e.code, direction: this.model.direction });
  };

  p.handleDragEnd = function () {
    //console.log("handleDragEnd");
    this.model.direction = 0;
    gsap.killTweensOf(this.moveObj);
    //this.dispatchEvent({ type: "change", keydown: false, keyup: true, code: e.code, direction: this.model.direction });
  };

  /**
   * TouchControllerVerlet keeps track of mouse/touch moving
   * @param {GameModel} model   The model
   * @param {jQuery} $target
   */
  function TouchControllerVerlet(model, $target) {
    // call super constructor.
    GameController.call(this, 'TouchControllerVerlet', model);
    this.$target = $target;
    //lib.pointerEvents.lockAxis = 'x';
    lib.pointerEvents.onDrag($target, this.handleDrag.bind(this));
    //type: "x", bounds: { minX: -320, maxX: 320, minY: 0, maxY: 0 },
    this.active = true;
  }

  // subclass extends superclass
  p = TouchControllerVerlet.prototype = Object.create(GameController.prototype);
  p.constructor = TouchControllerVerlet;

  p.setActive = function (active) {
    this.active = active;
  };

  p.kill = function () {
    lib.pointerEvents.offDrag(this.$target);
  };

  p.handleDrag = function (event) {
    var that = this,
      vectorPos = lib.pointerEvents.vectorPos,
      vx = vectorPos.vx;
    //console.log("");
    //console.log("TouchControllerVerlet", "handleDrag", "vx:", vx, "moveX:", moveX, "direction:", this.model.direction);
    //console.log("TouchControllerVerlet", "handleDrag", "event:", event.type, "touches:", event.touches);
    //console.log("TouchControllerVerlet", "handleDrag", "vectorPos.a:", vectorPos.a.x, "vectorPos.b:", vectorPos.b.x);
    //console.log("TouchControllerVerlet", "handleDrag", "rectStage.x:", this.model.rectStage.x, "rectStage.width:", this.model.rectStage.width);
    if (this.active) {
      if (vx < 0) {
        //left
        that.model.moveSpeedX = -this.model.MOVE_SPEED_X;
        that.model.direction = -1;
      } else if (vx > 0) {
        //right
        that.model.moveSpeedX = this.model.MOVE_SPEED_X;
        that.model.direction = 1;
      }
    }
    if (event.type === lib.pointerEvents.EVENT_UP) {
      this.handleDragEnd();
    }
    //this.dispatchEvent({ type: "change", keydown: true, keyup: false, code: e.code, direction: this.model.direction });
  };

  p.handleDragEnd = function () {
    //console.log("handleDragEnd");
    this.model.moveSpeedX = 0;
    this.model.direction = 0;
    this.model.playerSpeedX = 1;
    //this.dispatchEvent({ type: "change", keydown: false, keyup: true, code: e.code, direction: this.model.direction });
  };

  /*
  +++ e.acceleration Beschleunigung - Einfluss der Schwerkraft kompensiert - außer bei Geräten ohne Gyroskop! +++
  x: Represents the acceleration upon the x axis which is the west to east axis - West-Ost-Achse
  y: Represents the acceleration upon the y axis which is the south to north axis - Süd-Nord-Achse
  z: Represents the acceleration upon the z axis which is the down to up axis - Achse von unten nach oben

  +++ e.accelerationIncludingGravity - Quadratmetern pro Sekunde (m / s 2 ) +++
  x: Represents the acceleration upon the x axis which is the west to east axis - West-Ost-Achse
  y: Represents the acceleration upon the y axis which is the south to north axis - Süd-Nord-Achse
  z: Represents the acceleration upon the z axis which is the down to up axis - Achse von unten nach oben

  +++ e.rotationRate Gibt die Geschwindigkeit zurück, mit der sich das Gerät in Grad pro Sekunde um jede seiner Achsen dreht. +++
  das heißt, um eine Linie senkrecht zum Bildschirm gedreht zu werden
  alpha: The rate at which the device is rotating about its Z axis; that is, being twisted about a line perpendicular to the screen.
  beta : The rate at which the device is rotating about its X axis; that is, front to back.
  gamma: The rate at which the device is rotating about its Y axis; that is, side to side.
  */

  /**
   * MotionController keeps track of device motion
   * @param {VerletModel} model   The model
   * @param {Vector}      options A vector instance
   * @param {Rectangle}   options A rectangle instance
   */
  function MotionController(model) {
    // call super constructor.
    GameController.call(this, 'MotionController', model);
    // check for device motion event support
    /*if (typeof window.DeviceMotionEvent === 'undefined') {
        throw new Error("DeviceMotionEvent has to be supported or enabled!");
    }
    // Listen to motion events and update the position
    window.addEventListener('devicemotion', this.handleMotion.bind(this), true);
    */
    if (typeof window.DeviceOrientationEvent === 'undefined') {
      throw new Error("DeviceOrientationEvent has to be supported or enabled!");
    }
    window.addEventListener("deviceorientation", this.handleOrientation.bind(this), true);
    this.active = true;
    this.minGamma = 3;
  }

  // subclass extends superclass
  p = MotionController.prototype = Object.create(GameController.prototype);
  p.constructor = MotionController;

  p.setActive = function (active) {
    this.active = active;
  };

  p.kill = function () {
    //window.removeEventListener("deviceorientation", this.handleOrientation.bind(this), true);
  };

  p.handleOrientation = function (e) {
    // nach links < 1 oder nach rechts > 1
    this.model.orientationX = e.gamma;
    // nach oben > 1 oder nach unten < 1
    this.model.orientationY = e.beta;
    this.model.orientationZ = e.alpha;
    var moveSpeedX = mathMin(mathAbs(e.gamma) * this.model.FRICTION_DEVICE, this.model.DRAG_SPEED_X);
    //$('#consolas-1').html() +
    //$('#consolas-1').html('gamma: ' + Number(e.gamma).toFixed(3) + '<br>DRAG_SPEED_X: ' + this.model.DRAG_SPEED_X + '<br>Ctrl X: ' + Number(moveSpeedX).toFixed(2) + '<br>Model X: ' + Number(this.model.moveSpeedX).toFixed(2));
    if (this.active) {
      // nach links < 1 oder nach rechts > 1
      if (e.gamma < -this.minGamma) {
        //this.model.moveSpeedX = -this.model.DRAG_SPEED_X;
        //this.model.moveSpeedX = -moveSpeedX;
        this.model.moveSpeedX += (-moveSpeedX - this.model.moveSpeedX) * 0.15;
        this.model.direction = -1;
      } else if (e.gamma > this.minGamma) {
        //this.model.moveSpeedX = this.model.DRAG_SPEED_X;
        //this.model.moveSpeedX = moveSpeedX;
        //(this.moveX - this.prevX) * 0.075;
        this.model.moveSpeedX += (moveSpeedX - this.model.moveSpeedX) * 0.15;
        this.model.direction = 1;
      } else {
        this.model.moveSpeedX = 0;
        this.model.direction = 0;
      }
    }

    //this.dispatchEvent({ type: "change", orientation: true, origEvent: e });
  };

  /**
   * DragController keeps track of mouse/touch moving
   * @param {GameModel} model   The model
   */
  function DragController(model, $target) {
    // call super constructor.
    GameController.call(this, 'DragController', model);
    console.log("DragController", "model", this.model);
    var that = this;
    //register plugin and create draggable instance
    //gsap.registerPlugin(InertiaPlugin);
    this.speed = 1;
    this.$target = $target;
    this.draggable = Draggable.create($target, {
      autoScroll: 0,
      type: "x",
      bounds: {
        minX: -320,
        maxX: 320,
        minY: 0,
        maxY: 0
      },
      inertia: true,
      callbackScope: that,
      allowNativeTouchScrolling: false,
      //cursor: 'url(./assets/ui-hand.png), auto',
      minimumMovement: 15,
      onDrag: that.handleDrag,
      //onDrag: function () {},
      onDragEnd: that.handleDragEnd,
    })[0];
    this.active = true;
  }

  // subclass extends superclass
  p = DragController.prototype = Object.create(GameController.prototype);
  p.constructor = DragController;

  p.setActive = function (active) {
    this.active = active;
  };

  p.kill = function () {
    this.draggable.kill();
  };

  p.handleDrag = function () {
    //momentary velocity *requires InertiaPlugin
    //startDirection = this.getDirection("start"),
    var DRAG_SPEED_X = this.model.DRAG_SPEED_X,
      momentaryDirection = this.draggable.getDirection("velocity");
    console.log("DragController", "handleDrag", "momentaryDirection:", momentaryDirection, "deltaX:", this.draggable.deltaX, "isThrowing:", this.draggable.isThrowing);
    //console.log("DragController", "handleDrag", "this:", this);
    //console.log("DragController", "handleDrag", "this.draggable:", this.draggable);
    this.model.momentaryDirection = momentaryDirection;
    this.speed += 0.25;
    if (this.speed > DRAG_SPEED_X) {
      this.speed = DRAG_SPEED_X;
    }
    switch (momentaryDirection) {
      case 'left':
        this.model.moveSpeedX = -this.speed;
        this.model.direction = -1;
        break;
      case 'right':
        this.model.moveSpeedX = this.speed;
        this.model.direction = 1;
        break;
    }
    //this.dispatchEvent({ type: "change", keydown: true, keyup: false, code: e.code, direction: this.model.direction });
  };

  p.handleDragEnd = function () {
    console.log("handleDragEnd");
    //gsap.set(this.$target, { x: 0 });
    this.model.moveSpeedX = 0;
    this.model.direction = 0;
    this.speed = 1;
    //this.dispatchEvent({ type: "change", keydown: false, keyup: true, code: e.code, direction: this.model.direction });
  };

  /**
   * SoundCtrlAudioContext keeps track of audio
   * @param {GameModel} model   The model
   * @param {String}    type    A rectangle instance
   */
  function SoundCtrlAudioContext(model) {
    // call super constructor.
    GameController.call(this, 'SoundCtrlAudioContext', model);
    //console.log("SoundCtrlAudioContext", "model", this.model);
  }

  // subclass extends superclass
  p = SoundCtrlAudioContext.prototype = Object.create(GameController.prototype);
  p.constructor = SoundCtrlAudioContext;

  p.create = function (ready) {
    // Fix up prefixing
    window.AudioContext = window.AudioContext || window.webkitAudioContext;
    //console.log("SoundCtrlAudioContext", "create", "window.AudioContext", window.AudioContext);
    this.context = new window.AudioContext();
    //
    var key, sound,
      that = this,
      sounds = this.model.sounds,
      length = Object.keys(sounds).length;
    for (key in sounds) {
      if (sounds.hasOwnProperty(key)) {
        sound = sounds[key];
        length--;
        //console.log("SoundCtrlAudioContext", "create", "length:", length, "key:", key, "sounds[key]", sound);
        this.loadSound(sound, (length === 0), ready);
      }
    }
  };

  //@private
  p.loadSound = function (sound, last, callback) {
    var that = this,
      request = new XMLHttpRequest();
    request.open('GET', sound.src, true);
    request.responseType = 'arraybuffer';
    // Decode asynchronously
    request.onload = function () {
      that.context.decodeAudioData(request.response, function (buffer) {
        if (!buffer) {
          console.log('Error decoding file data: ' + sound.src);
          return;
        }
        sound.buffer = buffer;
        //console.log("SoundCtrlAudioContext", "loadSound", "sound:", sound);
        if (last) {
          callback('ready');
        }
      });
    };
    request.onerror = function () {
      console.log('BufferLoader: XHR error');
    };
    request.send();
    //console.log("SoundCtrlAudioContext", "loadSound", "sound:", sound, "last:", last);
  };
  //@private
  p.playSound = function (buffer, time, volume, autostop) {
    if (typeof autostop === 'undefined') {
      autostop = false;
    }
    //console.log("SoundCtrlAudioContext", "playSound", "time:", time, "volume:", volume);
    //buffer, time, volume
    var source, gainNode;
    // creates a sound source AudioBufferSourceNode
    source = this.context.createBufferSource();
    // tell the source which sound to play
    source.buffer = buffer;
    // connect the source to the context's destination (the speakers)
    source.connect(this.context.destination);
    // Create a gain node
    /*gainNode = this.context.createGain();
    // Connect the source to the gain node
    source.connect(gainNode);
    // Connect the gain node to the destination
    gainNode.connect(this.context.destination);
    // Set the volume
    gainNode.gain.value = volume;*/
    //gainNode.gain.setValueAtTime(volume, 0);
    // play the source at the deisred time 0=now
    //source.start(time);
    if (source.noteOn) {
      source.noteOn(0);
    } else {
      source.start(0);
    }
  };

  /*AudioMixer.waContext = new window.AudioContext;
      var i = AudioMixer.waContext.createBuffer(1, 1, 22050),
          source = AudioMixer.waContext.createBufferSource();
      source.buffer = i;
      source.connect(AudioMixer.waContext.destination);
      source.noteOn ? source.noteOn(0) : source.start(0);*/

  p.play = function (sound, time, volume) {
    if (!time) {
      time = 0;
    }
    if (typeof volume === 'undefined') {
      volume = 1;
    }
    //early out if sound off
    if (!this.model.isSoundOn) {
      return false;
    }
    var soundItem = (typeof sound === 'object') ? sound : this.model.sounds[sound];
    this.playSound(soundItem.buffer, time, volume);
    //this.dispatchEvent({ type: "start" });
  };

  p.stop = function (sound) {
    var soundItem = (typeof sound === 'object' && sound.elem) ? sound : this.model.sounds[sound];
    //console.log("SoundCtrlAudioContext", "stop soundItem", soundItem);
    if (soundItem && soundItem.elem && soundItem.elem.pause) {
      soundItem.elem.pause();
    }
    //this.dispatchEvent({ type: "stop" });
  };

  // save specific controller classes in global namespace
  // and leave abstract GameController private
  lib.GameController = GameController;
  lib.SoundCtrlAudioContext = SoundCtrlAudioContext;
  lib.KeyController = KeyController;
  lib.KeyControllerGsap = KeyControllerGsap;
  lib.DragController = DragController;
  lib.MotionController = MotionController;
  lib.TouchControllerEuler = TouchControllerEuler;
  lib.TouchControllerVerlet = TouchControllerVerlet;

}());

/**
 * Hornbach Arcade Style Game SAT PIXI WEBGL
 * Author   : J. Pfeifer joerg.pfeifer@egplusww.com
 * Created  : 06.12.2020
 * Modified : 210130 | 210531 | 210621 | 210706 | 210708 | 210902
 */
(function ($) {

  'use strict';

  //Aliases
  var Application, AnimatedSprite, Container, Graphics, loader, resources, Sprite, TilingSprite,
    egp = window.EGP,
    game = {
      uiState: ''
    },
    extURL = 'https://mcdo-letzi-quest.info/hornbach-erleben-sie-hornbach-spiel/',
    pixi = {
      spriteJson: "assets/game-sprite-pixi.json"
    },
    gameData = egp.data,
    languageData = egp.language[gameData.language],
    isloaded = false,
    //model
    gameModel,
    //ctrl
    soundCtrl = null,
    playerCtrl = null,
    //DOM references
    $hand = $('#hand-1'),
    $infoBtn = $('#info-btn'),
    $infoGame = $('#info-game'),
    $backBtn = $('#back-btn'),
    $startBtn = $('#start-btn'),
    $playBtn = $('#play-btn'),
    $soundBtn = $('#sound-btn > div'),
    $againBtn = $('#again-btn'),
    $shareBtn = $('#share-btn'),
    $submitBtn = $('#submit-btn'),
    $highscoreBtn = $('#highscore-btn'),
    $copyLinkBtn = $('#copy-link-btn'),
    $socialShareUI = $('#ui-social-share'),
    //$socialShareUIIcons = $socialShareUI.find('.social .icon'),
    $socialShareUIClose = $socialShareUI.find('.close-btn'),
    $loader = $('#loader'),
    //$imagesEnd = $('.image-end'),
    $videoEnd = $(),
    $videoWrapper = $('.video'),
    $groundMoveDummy = $('#ground-move-dummy'),
    $dragTarget = $('#ground-move-dummy .tracker'),
    $highscorePoints = $('#highscore-points'),
    $highscoreAll = $('#highscore-all'),
    $highscoreForm = $('#highscore-form'),
    $highscoreInput = $('#nickname'),
    $score = $('#score'),
    $life = $('#life'),
    $hearts,
    $content = $('#game-wrapper .game-content'),
    $ui = $('#ui'),
    $game = $('#game'),
    $playground = $('#playground'),
    //OS_SYSTEM = 'desktop',
    OS_SYSTEM = lib.GameController.getMobileOperatingSystem();
  //
  Function.prototype.bindWithFFX = function (thisArg, ffx) {
    //console.log("");
    //console.log("Function -> bindWithFFX", "this.bind:", this.bind, "thisArg:", thisArg, "ffx:", ffx);
    var that = this;
    //args = (arguments.length > 1 ? [arguments[0]] : Array.apply(null, arguments));
    return function (e) {
      //console.log("");
      //console.log("Function -> bindWithFFX", "e:", e);
      if (e.currentTarget && typeof ffx === 'function') {
        ffx(e.currentTarget);
      }
      return that.call(thisArg, e);
    };
  };

  function buttonFFXClickThrough(target) {
    //console.log();
    //console.log("buttonFFXClickThrough", "target:", target);
    gsap.to(target, {
      scale: 1.05,
      duration: 0.2,
      ease: 'back.inOut',
      onComplete: function () {
        gsap.to(target, {
          scale: 0.9,
          duration: 0.25,
          ease: 'back',
          onComplete: function () {
            gsap.to(target, {
              scale: 1,
              duration: 0.3,
              ease: 'back'
            });
          }
        });
      }
    });
  }

  function resize() {
    var mobileDifHeight = 100,
      desktopDifHeight = 260,
      innerWidth = window.innerWidth,
      innerHeight = window.innerHeight,
      mobileSafe = innerHeight - mobileDifHeight,
      desktopSafe = innerHeight - desktopDifHeight,
      width = gameModel.rectStage.width,
      height = gameModel.rectStage.height,
      safeZoneHeight = (OS_SYSTEM === 'desktop') ? desktopSafe : mobileSafe,
      transformOrigin = (OS_SYSTEM === 'desktop' || innerWidth > 767) ? '50% 50%' : '50% 0%',
      factorScale = Math.min(safeZoneHeight / height, 1.5),
      scaledWidth = width * factorScale,
      scaledHeight = height * factorScale,
      stageBounding = $content[0].getBoundingClientRect();
    //
    gameModel.rectStage.x = Math.floor(stageBounding.x);
    gameModel.rectStage.y = Math.floor(stageBounding.y);
    //console.log("resize:");
    //console.log("resize", "stageBounding:", stageBounding);
    if (scaledWidth > innerWidth) {
      //console.log("resize calculate new factor via width");
      factorScale = (innerWidth - 20) / width;
      scaledHeight = height * factorScale;
      if (scaledHeight > innerHeight - mobileDifHeight) {
        //console.log("resize calculate new factor via height");
        factorScale = (innerHeight - mobileDifHeight) / height;
      }
    }
    //
    //console.log("resize", "innerWidth:", innerWidth, "innerHeight:", innerHeight, "rectStage.height:", height);
    //console.log("resize", "scaledWidth:", scaledWidth, "scaledHeight:", scaledHeight);
    //console.log("resize", "safeZoneHeight:", safeZoneHeight, "factorScale:", factorScale);
    gsap.set($('#sound-btn'), {
      x: -stageBounding.left,
      y: stageBounding.top
    });
    gsap.set($content, {
      scale: factorScale,
      transformOrigin: transformOrigin
    });
    gameModel.factorScale = factorScale;
  }

  //@private protected

  // ++++ MEDIATOR GAME OBJECT +++++

  game.getVideo = function (id) {
    return $videoWrapper.find('#' + id);
  };

  game.clearGame = function () {
    //deactivate player ctrl and place
    var i, d, level,
      levels = gameModel.levels,
      length = levels.length;
    for (i = 0; i < length; i++) {
      level = levels[i];
      pixi.resetLevel(i);
      if (i === 0) {
        pixi.levels.getChildAt(i).y = gameModel.y;
      } else {
        pixi.levels.getChildAt(i).y = gameModel.y - gameModel.levelHeight;
      }
    }
    pixi.activateLevel(0);
    pixi.activateLevel(1);
    playerCtrl.setActive(false);
    gameModel.setX(gameModel.rectStage.width / 2 - gameModel.rectPlayer.width / 2);
    gameModel.setY(gameModel.rectStage.height - gameModel.levelHeight);
    gameModel.currentLevel = 0;
    gameModel.score = 0;
    gameModel.life = 3;
    gameModel.scrollSpeedY = gameModel.SCROLL_SPEED_Y;
    gameModel.collectedItems = [];
    pixi.levels.getChildAt(gameModel.currentLevel).y = gameModel.y;
    pixi.levels.getChildAt(gameModel.getNextLevelIndex()).y = (gameModel.y - gameModel.levelHeight);
    pixi.movePlayer();
    $hearts.removeClass('ui-life-lost').addClass('ui-life-full');
    $score.text('00000');
    $submitBtn.addClass('hidden');
    $submitBtn.off('click', game.submitForm);
    $game.hide();
  };

  game.checkRequestPermissionMotionEvent = function () {
    if (typeof OS_SYSTEM === "number" && OS_SYSTEM >= 13 && playerCtrl.name === 'MotionController' && DeviceMotionEvent.requestPermission) {
      DeviceMotionEvent.requestPermission().then(function (response) {
        //$('#consolas-1').html('requestPermission:<br>response: ' + response);
        if (response === 'granted') {
          playerCtrl = new lib.MotionController(gameModel);
        } else {
          //fallback to TouchControllerEuler
          playerCtrl = new lib.TouchControllerEuler(gameModel, $dragTarget);
        }
      }, function (value) {
        //$('#consolas-1').html('requestPermission:<br>failed: ' + value);
        //fallback to TouchControllerEuler
        playerCtrl = new lib.TouchControllerEuler(gameModel, $dragTarget);
      });
    }
  };

  game.load = function () {
    $loader.show();
    //game.initGame();
    resize();
    $startBtn.off('click', game.load);
    $startBtn.hide();
    gameModel.state = lib.GameModel.STATE_LOAD;
    //this is the active user call for AudioContext
    soundCtrl.create(function () {
      //console.log("soundCtrl", "loaded");
      //$startBtn.off('click', game.load);
      //$startBtn.hide();

    });
    //iOS only - works with user click
    game.checkRequestPermissionMotionEvent();
    //game.createUI -> game.loadPixi -> game.initPixi -> pixi.setup -> game.initialize
    game.loadPixi(function () {
      game.initPixi();
    });
  };

  game.loadSounds = function () {
    //console.log("loadSounds");
    if (gameModel.state === lib.GameModel.STATE_INTRO) {
      gameModel.state = lib.GameModel.STATE_LOAD;
      /*if (OS_SYSTEM !== 'desktop') {
          game.toggleFullScreen();
      }*/
      //iOS only - works with user click
      game.checkRequestPermissionMotionEvent();
      //
      soundCtrl.create(function () {
        //console.log("loadSounds", "loaded");
        //$startBtn.off('click', game.loadSounds);
        $startBtn.off('click', game.load);
        $startBtn.hide();
        $playBtn.removeClass('hidden');
      });
    }
  };

  game.startGame = function () {
    //console.log("startame");
    //console.log("startGame", "gameModel.state", gameModel.state);
    if (gameModel.state === lib.GameModel.STATE_LOAD || gameModel.state === lib.GameModel.STATE_AGAIN) {
      gameModel.state = lib.GameModel.STATE_START;
      game.resizeGame();
      //Autoplay Policy - user must interact
      soundCtrl.play('start');
      $highscoreBtn.hide();
      $infoBtn.hide();
      gsap.delayedCall(1.0, function () {
        $groundMoveDummy.show();
        gsap.to($videoWrapper, {
          scale: 1.5,
          opacity: 0,
          duration: 0.5
        });
        gsap.to($game, {
          duration: 0.6,
          opacity: 1
        });
        gsap.to($playBtn, {
          scale: 0.5,
          opacity: 0,
          duration: 0.5,
          onComplete: function () {
            var $videoIntro = game.getVideo('video-intro');
            $videoIntro.get(0).pause();
            $videoIntro.get(0).currentTime = 0;
            $videoIntro.css('display', 'none');
            $ui.hide();
            $playBtn.addClass('hidden');
            //animate hand
            if (OS_SYSTEM !== 'desktop' && playerCtrl.name !== 'MotionController') {
              gsap.to($hand, {
                x: 100,
                opacity: 1,
                onComplete: function () {
                  gsap.to($hand, {
                    x: -100,
                    onComplete: function () {
                      gsap.to($hand, {
                        x: 0,
                        opacity: 0,
                        onComplete: function () {
                          $hand.hide();
                        },
                        duration: 0.5
                      });
                    },
                    duration: 0.8,
                    ease: 'power1.inOut',
                    repeat: 1,
                    yoyo: true
                  });
                },
                duration: 0.5,
                ease: 'power0'
              });
            }
            gsap.delayedCall(0.9, function () {
              game.runGame();
              soundCtrl.play('hupe');
            });
            //pixi.createScroller();
            /* gsap.delayedCall(0.1, function () {
                pixi.createScroller();
            }); */
          },
          ease: 'back.in'
        });
      });
    }
  };

  game.toggleSound = function () {
    if (!gameModel.isSoundOn) {
      $soundBtn.removeClass('ui-sound-off').addClass('ui-sound-on');
      gameModel.isSoundOn = true;
    } else {
      $soundBtn.removeClass('ui-sound-on').addClass('ui-sound-off');
      gameModel.isSoundOn = false;
    }
  };

  game.pauseGame = function () {
    // START | PAUSE | RUN | DEAD | NEXT | HELP | HIGHSCORE
    if (gameModel.state === lib.GameModel.STATE_PAUSE) {
      return;
    }
    gameModel.state = lib.GameModel.STATE_PAUSE;
    pixi.state = pixi.statePause;
    //pixi.app.ticker.stop();
    //pixi.app.ticker.remove(pixi.gameLoop);
  };

  game.runGame = function () {
    if (gameModel.state === lib.GameModel.STATE_RUN) {
      return;
    }
    gameModel.state = lib.GameModel.STATE_RUN;
    //Start the game loop by adding the `gameLoop` function to
    //Pixi's `ticker` and providing it with a `delta` argument.
    //pixi.app.ticker.start();
    pixi.state = pixi.stateRun;
    //pixi.state = pixi.stateDebug;
  };

  game.setScore = function (value) {
    gameModel.score += value;
    var scoreTxt = (gameModel.score + 100000).toString().substr(1);
    $score.text(scoreTxt);
  };

  game.playAgain = function (callback) {
    console.log();
    console.log("game.playAgain", "uiState:", game.uiState, "current state:", gameModel.state);
    game.clearGame();
    //window.location.reload();
    //$imagesEnd.css('display', 'none');
    $videoEnd.css('display', 'none');
    game.getVideo('video-lost').css('display', 'none');
    game.getVideo('video-highscore').css('display', 'none');
    $ui.hide();
    $game.show();
    playerCtrl.setActive(true);
    $againBtn.addClass('hidden');
    $highscorePoints.hide();
    $highscoreAll.hide();
    gsap.to($game, {
      duration: 0.6,
      opacity: 1
    });
    //STATE_AGAIN
    gameModel.state = lib.GameModel.STATE_AGAIN;
    game.startGame();
  };

  game.showAgain = function (callback) {
    $againBtn.removeClass('hidden');
    gsap.fromTo($againBtn, {
      scale: 0.2,
      opacity: 0
    }, {
      scale: 1,
      opacity: 1,
      ease: 'back',
      delay: 1.0,
      duration: 0.5,
      onComplete: typeof callback === 'function' ? callback : function () {}
    });
  };

  //TODO: 05.07.21 skip highscore
  game.submitForm = function () {
    var nickname = $highscoreInput.val(),
      $videoHS = game.getVideo('video-highscore'),
      $videoWin = game.getVideo('video-win');
    if (nickname.length < 2) {
      return;
    }
    //hide form to prevent double
    $videoWin.css('display', 'none');
    $highscoreForm.hide();
    gameModel.state = lib.GameModel.STATE_HIGHSCORE;
    gameModel.nickname = nickname;
    game.result = JSON.stringify({
      "score": gameModel.score,
      "name": gameModel.nickname
    });
    //console.log("submitForm", "score", gameModel.score);
    //console.log("submitForm", "nickname", gameModel.nickname);
    //console.log("submitForm", "$videoHS.get(0):", $videoHS.get(0));
    //$videoHS[0].scrollTo(0, 1);
    $videoHS.css('display', 'inline-block');
    $videoHS.get(0).play();
    gsap.fromTo($videoHS, {
      opacity: 0
    }, {
      opacity: 1,
      duration: 0.5
    });
    $shareBtn.addClass('hidden');
    //send highscore data
    //to extern sever: https://mcdo-letzi-quest.info/hornbach-erleben-sie-hornbach-spiel/ -> extURL
    $.ajax({
      type: 'post',
      url: extURL + '_save_highscore.php',
      data: game.result,
      dataType: 'json',
      contentType: "application/json",
      cache: false,
      success: function (data) {
        console.log("submitForm", "success", "data:", data);
        //console.log("submitForm", "success", "$highscoreAll.find(.wrapper):", $highscoreAll.find('.wrapper'));
        //$againBtn.addClass('hidden');
        $shareBtn.off('click.share');
        $shareBtn.addClass('hidden');
        gsap.set($againBtn, {
          y: 0
        });
        $againBtn.addClass('hidden');
        if (data.type && data.type === "error") {
          $highscorePoints.hide();
          //game.showAgain(game.clearGame);
          game.showAgain();
          return;
        }
        game.fillHighscore(data);
        $highscorePoints.hide();
        gsap.delayedCall(1.5, function () {
          $highscoreAll.show();
          //game.showAgain(game.clearGame);
          game.showAgain();
        });

      }
    });
  };
  //TODO: 05.07.21 skip highscore
  game.fillHighscore = function (data) {
    console.log("");
    console.log("fillHighscore", "data:", data);
    $highscoreAll.find('.wrapper .item').remove();
    var i, item, name, l = data.highscore.length;
    for (i = 0; i < l; i++) {
      item = data.highscore[i];
      name = item.name.substr(0, 16);
      //console.log("fillHighscore", item);
      $highscoreAll.find('.wrapper').append($('<div class="item"><div class="item index">' + (i + 1) + '.</div><div class="item name">' + name + '</div><div class="item score">' + item.score + '</div></div>'));
    }
  };

  game.showForm = function () {
    gameModel.state = lib.GameModel.STATE_FORM;
    $highscoreForm.show();
    $highscoreInput.on('focus', function () {
      var $videoWin = game.getVideo('video-win');
      $videoWin.get(0).pause();
      $videoWin.get(0).currentTime = 0;
      $submitBtn.removeClass('hidden');
    });
  };

  game.winGame = function () {
    console.log();
    console.log("game.winGame", "uiState:", game.uiState, "current state:", gameModel.state);
    var $videoWin = game.getVideo('video-win');
    $ui.show();
    $videoWin.css('display', 'inline-block');
    $videoWin.get(0).play();
    gsap.to($game, {
      duration: 0.5,
      opacity: 0
    });
    gsap.to($videoWrapper, {
      scale: 1,
      opacity: 1,
      duration: 0.5,
      delay: 0.65,
      onComplete: function () {
        $highscorePoints.find('.points').text(gameModel.score);
        gsap.set($highscorePoints, {
          y: 192
        });
        $highscorePoints.show();
        $shareBtn.removeClass('hidden');
        gsap.set($againBtn, {
          y: -28
        });
        game.showAgain();
        $shareBtn.on('click.share', game.toggleSocialShareUI.bindWithFFX(game, buttonFFXClickThrough));
        gsap.delayedCall(1.0, game.showForm);
      }
    });
  };

  game.looseGame = function () {
    var $videoLost = game.getVideo('video-lost');
    $ui.show();
    $videoLost.css('display', 'inline-block');
    $videoLost.get(0).play();
    gsap.to($game, {
      duration: 0.5,
      opacity: 0
    });
    gsap.to($videoWrapper, {
      scale: 1,
      opacity: 1,
      duration: 0.5,
      delay: 0.35
    });
    gsap.set($highscorePoints, {
      y: 380
    });
    $highscorePoints.find('.points').text(gameModel.score);
    game.clearGame();
    game.showAgain(function () {
      $highscorePoints.show();
    });
  };

  game.gameOver = function () {
    $groundMoveDummy.hide();
    game.result = JSON.stringify({
      "score": gameModel.score
    });
    //TODO: 05.07.21 skip highscore
    $ui.show();
    //Endscreen-Logik: 1 - 999 | 1000 - 1999 | 2000 - 2999 | 3000 - 4999 | 5000 +
    if (gameModel.score < 1000) {
      $videoEnd = game.getVideo('video-result-1');
      //$imagesEnd.eq(0).css('display', 'block');
    } else if (gameModel.score < 2000) {
      $videoEnd = game.getVideo('video-result-2');
      //$imagesEnd.eq(1).css('display', 'block');
    } else if (gameModel.score < 3000) {
      $videoEnd = game.getVideo('video-result-3');
      //$imagesEnd.eq(2).css('display', 'block');
    } else if (gameModel.score < 5000) {
      $videoEnd = game.getVideo('video-result-4');
      //$imagesEnd.eq(3).css('display', 'block');
    } else if (gameModel.score >= 5000) {
      $videoEnd = game.getVideo('video-result-5');
      //$imagesEnd.eq(4).css('display', 'block');
    }
    $videoEnd.css('display', 'inline-block');
    $videoEnd.get(0).play();
    gsap.to($game, {
      duration: 0.5,
      opacity: 0
    });
    gsap.to($videoWrapper, {
      scale: 1,
      opacity: 1,
      duration: 0.5,
      delay: 0.35,
      onComplete: function () {
        gsap.set($highscorePoints, {
          y: 290
        });
        $highscorePoints.find('.points').text(gameModel.score);
        game.clearGame();
        $shareBtn.removeClass('hidden');
        gsap.fromTo($shareBtn, {
          opacity: 0,
          scale: 0.5
        }, {
          opacity: 1,
          scale: 1,
          ease: 'back',
          duration: 0.5
        });
        //$shareBtn.on('click.share', game.toggleSocialShareUI.bindWithFFX(game, buttonFFXClickThrough));
        game.showAgain(function () {
          $highscorePoints.show();
        });
      }
    });

    /*
    $.ajax({
        type: 'post',
        url: extURL + '_get_highscore_index.php',
        data: game.result,
        dataType: 'json',
        contentType: "application/json",
        cache: false,
        success: function (data) {
            console.log("gameOver", data);
            //"WINNER" oder "LOOSER"
            if (data === "WINNER") {
                game.winGame();
            } else if (data === "LOOSER") {
                game.looseGame();
            } else {
                console.log("ERROR gameOver", data);
            }
        }
    });
    */
  };

  game.setLife = function (value) {
    gameModel.setLife(value);
    var isDead = !gameModel.life;
    //console.log("+++ setLife IS DEAD +++", 'gameModel.life', gameModel.life, 'isDead', isDead);
    gsap.to($hearts.eq(gameModel.life), {
      scale: 0.15,
      duration: 0.3,
      delay: 0.15,
      ease: 'back.in',
      onComplete: function () {
        $hearts.eq(gameModel.life).removeClass('ui-life-full').addClass('ui-life-lost');
        gsap.to($hearts.eq(gameModel.life), {
          scale: 1,
          ease: 'back',
          duration: 0.6,
          onComplete: function () {
            if (isDead) {
              //GAME OVER GET HIGHSCORE
              game.gameOver();
            } else {
              pixi.restartLevel();
            }
          }
        });
      }
    });
  };

  //TODO: 05.07.21 skip highscore
  game.toggleHighscore = function () {
    console.log("");
    console.log("game.toggleHighscore", "uiState:", game.uiState, "current state:", gameModel.state);
    var currState = gameModel.state,
      $videoInfo = game.getVideo('video-info'),
      $videoHS = game.getVideo('video-highscore');
    if (game.uiState === 'info') {
      game.toggleInfo();
    }
    game.uiState = 'highscore';
    if ($videoHS.css('display') === 'none') {
      if (currState === lib.GameModel.STATE_RUN) {
        game.pauseGame();
      } else if (currState === lib.GameModel.STATE_INTRO) {
        $startBtn.addClass('hidden');
      } else if (currState === lib.GameModel.STATE_LOAD) {
        $playBtn.addClass('hidden');
      }
      $backBtn.removeClass('hidden');
      $videoInfo.css('display', 'none');
      $videoHS.css('display', 'inline-block');
      $videoHS.get(0).play();
      gsap.fromTo($videoHS, {
        opacity: 0
      }, {
        opacity: 1,
        duration: 0.5
      });
      gsap.to($videoWrapper, {
        scale: 1,
        opacity: 1,
        duration: 0.5,
        onComplete: function () {
          //headers.append('Access-Control-Allow-Origin', 'http://localhost:3000');
          //headers.append('Access-Control-Allow-Credentials', 'true');
          $.ajax({
            type: 'post',
            url: extURL + '_get_highscore_100.php',
            //data: JSON.stringify({ "score": gameModel.score }),
            dataType: 'json',
            contentType: "application/json",
            cache: false,
            success: function (data) {
              console.log(" toggleHighscore", data);
              if (game.uiState === 'highscore') {
                game.fillHighscore(data);
                $highscoreAll.show();
              }
            }
          });
        }
      });
    } else {
      if (currState === lib.GameModel.STATE_PAUSE) {
        game.runGame();
      } else if (currState === lib.GameModel.STATE_INTRO) {
        $startBtn.removeClass('hidden');
        //$infoBtn.show();
      } else if (currState === lib.GameModel.STATE_LOAD) {
        $playBtn.removeClass('hidden');
        //$infoBtn.show();
      }
      $highscoreAll.hide();
      $videoHS.css('display', 'none');
      $backBtn.addClass('hidden');
      game.uiState = '';
      $infoGame.hide();
    }
  };

  game.toggleInfo = function () {
    console.log();
    console.log("game.toggleInfo", "uiState:", game.uiState, "current state:", gameModel.state);
    console.log("game.toggleInfo", "this:", this, "arguments:", arguments);
    if (game.uiState === 'highscore') {
      game.toggleHighscore();
    }
    game.uiState = 'info';
    var $videoInfo = game.getVideo('video-info'),
      $videoHS = game.getVideo('video-highscore');
    if ($videoInfo.css('display') === 'none') {
      if (gameModel.state === lib.GameModel.STATE_INTRO) {
        $startBtn.hide();
        //$highscoreBtn.hide();
      }
      if (gameModel.state === lib.GameModel.STATE_LOAD) {
        $playBtn.hide();
        //$highscoreBtn.hide();
      }
      $videoHS.css('display', 'none');
      $videoInfo.css('display', 'inline-block');
      $videoInfo.get(0).play();
      gsap.delayedCall(0.3, function () {
        $infoGame.show();
        gsap.fromTo($infoGame, {
          opacity: 0
        }, {
          opacity: 1,
          duration: 0.7
        });
        $backBtn.removeClass('hidden');
      });
    } else {
      if (gameModel.state === lib.GameModel.STATE_INTRO) {
        $startBtn.show();
        //$highscoreBtn.show();
      }
      if (gameModel.state === lib.GameModel.STATE_LOAD) {
        $playBtn.show();
        //$highscoreBtn.show();
      }
      $videoInfo.css('display', 'none');
      $backBtn.addClass('hidden');
      game.uiState = '';
      gsap.to($infoGame, {
        opacity: 0,
        duration: 0.4,
        onComplete: function () {
          $infoGame.hide();
        }
      });
    }
  };

  game.handleBackBtn = function () {
    if (game.uiState === 'info') {
      game.toggleInfo();
    } else if (game.uiState === 'highscore') {
      game.toggleHighscore();
    }
  };

  game.toggleSocialShareUI = function () {
    //$socialShareUI, $socialShareUIIcons, $socialShareUIClose
    //console.log();
    //console.log("game.toggleSocialShareUI", "uiState:", game.uiState, "current state:", gameModel.state);
    if (game.uiState !== 'social') {
      game.uiState = 'social';
      $socialShareUI.show();
      $socialShareUIClose.on('click.social', game.toggleSocialShareUI.bindWithFFX(game, buttonFFXClickThrough));
    } else {
      game.uiState = '';
      $socialShareUI.hide();
      $socialShareUIClose.off('click.social');
    }
  };

  game.copyLink = function () {
    //window.EGPClipboard.copyText('https://online.e-graphics-germany.de/clients/hornbach_de/minigame_2020_11/arcade_game_HTML5_PIXI_V08_201128/');
    //window.EGPClipboard.copyText(encodeURIComponent(location.href));
    window.EGPClipboard.copyText(window.location.href);
    if (navigator.share) {
      navigator.share({
        title: game.shareText,
        text: game.shareText,
        url: window.location.href
      });
      //.then(() => console.log('Share complete'))
      //.error((error) => console.error('Could not share at this time', error));
    }
  };

  game.registerEvents = function () {
    $highscoreBtn.on('click', game.toggleHighscore.bindWithFFX(game, buttonFFXClickThrough));
    $infoBtn.on('click', game.toggleInfo.bindWithFFX(game, buttonFFXClickThrough));
    $backBtn.on('click', game.handleBackBtn.bindWithFFX(game, buttonFFXClickThrough));
    $startBtn.on('click', game.load.bindWithFFX(game, buttonFFXClickThrough));
    $playBtn.on('click', game.startGame.bindWithFFX(game, buttonFFXClickThrough));
    $soundBtn.on('click', game.toggleSound.bindWithFFX(game, buttonFFXClickThrough));
    $againBtn.on('click', game.playAgain.bindWithFFX(game, buttonFFXClickThrough));
    $submitBtn.on('click', game.submitForm.bindWithFFX(game, buttonFFXClickThrough));
    $copyLinkBtn.on('click', game.copyLink.bindWithFFX(game, buttonFFXClickThrough));
    $shareBtn.on('click.share', game.toggleSocialShareUI.bindWithFFX(game, buttonFFXClickThrough));
    //game.toggleSocialShareUI();
    // register keyboard events desktop
    document.addEventListener('keydown', function (event) {
      var key = event.keyCode;
      if (key === 37 || key === 38 || key === 39 || key === 40) {
        event.preventDefault();
      }
      switch (event.code) {
        case 'Space':
          if (gameModel.state === lib.GameModel.STATE_INTRO) {
            game.loadSounds();
          } else if (gameModel.state === lib.GameModel.STATE_LOAD) {
            game.startGame();
          } else if (gameModel.state === lib.GameModel.STATE_AGAIN) {
            game.playAgain();
          }
          /* else {
                             //DEBUGGING
                             if (gameModel.state === lib.GameModel.STATE_PAUSE) {
                                 game.runGame();
                             } else if (gameModel.state === lib.GameModel.STATE_RUN) {
                                 game.pauseGame();
                             }
                         } */
          break;
        case 'Enter':
          //submit form
          if (gameModel.state === lib.GameModel.STATE_FORM) {
            game.submitForm();
          }
          //if (gameModel.state === lib.GameModel.STATE_HIGHSCORE) {}
          break;
        case 'KeyZ':
          console.log("keydown", "gameModel:");
          console.log(gameModel);
          //
          break;
      }
      //console.log("keydown", "event.code:", event.code);
    });

    /* if (typeof document.hidden !== "undefined") {
        hidden = "hidden", visibilityChange = "visibilitychange", visibilityState = "visibilityState";
    } else if (typeof document.msHidden !== "undefined") {
        hidden = "msHidden", visibilityChange = "msvisibilitychange", visibilityState = "msVisibilityState";
    }

    var document_hidden = document.hidden;
    document.addEventListener("visibilitychange", function() {
        if (document_hidden != document[hidden]) {
            if (document[hidden]) {
                // Document hidden
            } else {
                // Document shown
            }
            document_hidden = document[hidden];
        }
    }); */
  };

  game.createUI = function (created, done) {
    //console.log("");
    //console.log("createUI", "languageData:", languageData);
    var i, item, $elem, autoplay, loop,
      l = languageData.length,
      countVideos = 0,
      onLoadVideos = function (e) {
        //console.log("createUI", "canplaythrough:", countVideos, e.target.src);
        countVideos--;
        e.target.removeEventListener('canplaythrough', onLoadVideos, false);
        // = true;
        if (countVideos === 0) {
          isloaded = true;
          done();
        }
      };
    //
    for (i = 0; i < l; i++) {
      item = languageData[i];
      //console.log("createUI", "+++ id:", item.id);
      //console.log("createUI", "item:", item);
      if (item.id.indexOf('btn') !== -1) {
        $('#' + item.id).css('line-height', item.lineHeight).find('span').text(item.text).css({
          'font-size': item.size,
          'padding-left': '3px'
        });
      } else if (item.id.indexOf('footer') !== -1) {
        $('#' + item.id).attr('href', item.href).attr('title', item.text).text(item.text);
      } else if (item.id === 'hornbach-logo') {
        $('#' + item.id).find('a').attr('href', item.href).attr('title', item.text);
      } else if (item.id === 'social-share') {
        $('#' + item.id).text(item.text);
        game.shareText = item.content;
      } else if (item.id.indexOf('video') !== -1) {
        autoplay = (item.id.indexOf('intro') !== -1) ? ' autoplay' : '';
        loop = (item.loop) ? ' loop' : '';
        //console.log("createUI", "item:", item.id, "autoplay:", autoplay);
        $elem = $('<video id="' + item.id + '" width="320" height="569" muted playsinline' + autoplay + loop + ' webkit-playsinline="" disablepictureinpicture="" controlslist="nodownload" poster="' + item.poster + '">');
        //$elem.append('<source src="' + item.src + '" type="video/mp4">')
        $videoWrapper.append($elem);
        $elem[0].src = item.src;
        $elem[0].load();
        //$elem[0].addEventListener('loadeddata', onLoadVideos, false);
        $elem[0].addEventListener('canplaythrough', onLoadVideos, false);
        countVideos++;
      }
    }
    //create Lifes
    l = gameModel.life;
    for (i = 0; i < l; i++) {
      $life.append($('<span class="heart icon ui-life-full"></span>'));
    }
    //get reference to life
    $hearts = $life.find('.heart');
    //$socialShareUI, $socialShareUIIcons, $socialShareUIClose
    //TODO: dynamic share url via game.js -> language
    //initialize sound icon
    if (gameModel.isSoundOn) {
      $soundBtn.removeClass('off').addClass('on');
    } else {
      $soundBtn.removeClass('on').addClass('off');
    }
    created();
  };

  game.initGame = function () {
    //
    //create model
    gameModel = new lib.GameModel(gameData);
    //
    gameModel.rectStage.width = 320;
    gameModel.rectStage.height = 570;
    // setting  rect player gameData.player.height
    gameModel.rectPlayer.width = gameData.player.width;
    gameModel.rectPlayer.height = gameData.player.height;
    gameModel.rectPlayerStart.width = gameData.player.width;
    gameModel.rectPlayerStart.height = gameData.player.heightStart;
    gameModel.rectPlayerMid.y = gameData.player.heightStart;
    gameModel.rectPlayerMid.width = gameData.player.width;
    gameModel.rectPlayerMid.height = gameData.player.heightMid;
    gameModel.rectPlayerEnd.y = gameData.player.heightStart + gameData.player.heightMid;
    gameModel.rectPlayerEnd.width = gameData.player.width;
    gameModel.rectPlayerEnd.height = gameData.player.heightEnd;
    //
    //set game model
    //gameModel.setGlobals(gameData);
    gameModel.currentLevel = 0;
    gameModel.levelHeight = 1920;
    //gameModel.levelHeight = 960;

    gameModel.width = gameModel.rectPlayer.width;
    gameModel.height = gameModel.rectPlayer.height;

    // create sound controller
    soundCtrl = new lib.SoundCtrlAudioContext(gameModel);

    // create player controller
    if (OS_SYSTEM === "desktop") {
      playerCtrl = new lib.KeyController(gameModel);
      gameModel.update = gameModel.updateVerletKey;
      $copyLinkBtn.css('display', 'none');
    } else {
      // V08
      /* if (typeof window.DeviceOrientationEvent !== 'undefined') {
          playerCtrl = new lib.MotionController(gameModel);
          gameModel.update = gameModel.updateVerlet;
      } else {
          playerCtrl = new lib.TouchControllerEuler(gameModel, $dragTarget);
          gameModel.update = gameModel.updateEuler;
      } */
      // V07
      //playerCtrl = new lib.TouchControllerEuler(gameModel, $dragTarget);
      //gameModel.update = gameModel.updateEuler;
      // V06
      playerCtrl = new lib.TouchControllerVerlet(gameModel, $dragTarget);
      gameModel.update = gameModel.updateVerlet;
    }
    //console.log("");
    //console.log("initGame", "OS_SYSTEM:", OS_SYSTEM);
    //console.log("initGame", "DeviceOrientationEvent:", window.DeviceOrientationEvent);
    //console.log("initGame", "playerCtrl.name:", playerCtrl.name);
    //console.log("initGame", "gameModel.x:", gameModel.x);
  };

  game.initialize = function () {
    //
    game.resizeGame();
    //$('#consolas-1').html($('#consolas-1').html() + '<br>initialize()' + '<br>innerHeight: ' + window.innerHeight + '<br>body height: ' + $('body').height());
    $playBtn.removeClass('hidden');
    gsap.fromTo($playBtn, {
      scale: 2,
      opacity: 0
    }, {
      scale: 1,
      opacity: 1,
      ease: 'back.inOut',
      delay: 0.5,
      duration: 0.6,
      onComplete: function () {
        $loader.hide();
        pixi.stateRun(1.0);
      }
    });

    setTimeout(function () {
      //console.log("");
      //console.log("initialize", "setTimeout scrollTo");
      window.scrollTo(0, 1);
    }, 1);
    /* if ($startBtn.hasClass('hidden')) {
        $startBtn.removeClass('hidden');
        gsap.fromTo($startBtn, { scale: 2, opacity: 0 }, { scale: 1, opacity: 1, ease: 'back.inOut', delay: 0.5, duration: 0.6 });
        $loader.hide();
        game.registerEvents();
        //render to stage
        pixi.stateRun(1.0);
        setTimeout(function () {
            console.log("");
            console.log("initialize", "setTimeout scrollTo");
            window.scrollTo(0, 1);
        }, 1);
    } */
  };

  game.initPixi = function () {
    resize();
    //Aliases
    Application = PIXI.Application;
    Container = PIXI.Container;
    Graphics = PIXI.Graphics;
    //ParticleContainer = PIXI.ParticleContainer;
    loader = PIXI.Loader.shared;
    resources = loader.resources;
    Sprite = PIXI.Sprite;
    TilingSprite = PIXI.TilingSprite;
    AnimatedSprite = PIXI.AnimatedSprite;
    //create pixi app
    pixi.app = new Application({
      width: gameModel.rectStage.width,
      height: gameModel.rectStage.height,
      antialias: true,
      transparent: false,
      resolution: 1
    });
    /* pixi.app = {
        renderer: new PIXI.Renderer({
            width: gameModel.rectStage.width,
            height: gameModel.rectStage.height,
            backgroundColor: 0xfcee21
        }),
        stage: new Container(),
        ticker: new PIXI.Ticker()
    }; */
    //Add the canvas that Pixi automatically created for you to the HTML document
    $playground[0].appendChild(pixi.app.view);
    //$playground[0].appendChild(pixi.app.renderer.view);
    //
    // register the plugin
    gsap.registerPlugin(PixiPlugin);
    // give the plugin a reference to the PIXI object
    PixiPlugin.registerPIXI(PIXI);
    //pixi.app.resizeTo = $game[0];
    pixi.app.ticker.add(pixi.gameLoop);
    pixi.app.ticker.start();
    //load a JSON file and run the `setup` function when it's done
    loader.add(pixi.spriteJson).load(pixi.setup);
    //$('#consolas-1').html($('#consolas-1').html() + '<br>initPixi' + '<br>innerHeight: ' + window.innerHeight);

  };

  game.loadPixi = function (callback) {
    // Load in JS
    var pixiJS = document.createElement('script');
    pixiJS.setAttribute("type", "text/javascript");
    pixiJS.setAttribute("src", "./js/pixi.min.js");
    pixiJS.onload = callback;
    document.getElementsByTagName("body")[0].appendChild(pixiJS);
  };

  game.resizeGame = function () {
    //
    //gameModel.playerStageY = gameModel.rectStage.height - Math.floor(gameModel.rectPlayer.height * 1.5);
    //console.log("game.resizeGame", "gameModel:", gameModel);
    //console.log("game.resizeGame", "pixi.movePlayer:", pixi.movePlayer);
    gameModel.playerStageY = 360;
    gameModel.setX(gameModel.rectStage.width / 2 - gameModel.rectPlayer.width / 2);
    gameModel.setY(gameModel.rectStage.height - gameModel.levelHeight);
    if (playerCtrl.moveObj) {
      playerCtrl.moveObj.x = gameModel.x;
    }
    //
    if (pixi.player) {
      pixi.player.x = gameModel.x;
      pixi.player.y = gameModel.playerStageY;
      //pixi.levels.getChildAt(gameModel.currentLevel).y = gameModel.y;
      //pixi.levels.getChildAt(gameModel.getNextLevelIndex()).y = (gameModel.y - gameModel.levelHeight);
      pixi.movePlayer();
    }

    //console.log("");
    //console.log("game.resizeGame", "gameModel.x:", gameModel.x);
    //gsap.set($startBtn, { y: 428 });
    //gsap.set($playBtn, { y: 428 });
    //gsap.set($againBtn, { y: 454 });
    $('body').removeClass('desktop mobile').addClass(OS_SYSTEM === 'desktop' ? 'desktop' : 'mobile');
    //
    //$('#consolas-1').html($('#consolas-1').html() + '<br>resizeGame' + '<br>innerHeight: ' + window.innerHeight + '<br>stage: ' + gameModel.rectStage.width + ', ' + gameModel.rectStage.height + '<br>game: ' + $game.height());
  };

  game.toggleFullScreen = function () {
    var doc = window.document,
      docEl = doc.documentElement,
      requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullScreen || docEl.msRequestFullscreen,
      cancelFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen || doc.msExitFullscreen;
    //
    if (requestFullScreen && !doc.fullscreenElement && !doc.mozFullScreenElement && !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
      requestFullScreen.call(docEl);
    } else if (cancelFullScreen) {
      cancelFullScreen.call(doc);
    }
  };

  // ++++++++ PIXI +++++++++++

  /**
   * Get an integer between min and max
   * @param {int} min random from min
   * @param {int} max to max int
   */
  pixi.randomInt = function (min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  };

  pixi.gameLoop = function (delta) {
    //Update the current game state:
    pixi.state(delta);
  };

  pixi.activateLevel = function (index) {
    //console.log("activateLevel", "index:", index);
    var i, obj,
      level = gameModel.levels[index],
      walls = level.walls,
      items = level.collectableItems,
      l = walls.length;
    level.sprite.visible = true;
    for (i = 0; i < l; i++) {
      obj = walls[i];
      //if (obj.y < gameModel.levelHeight) {
      if (obj.tl) {
        obj.tl.play();
      }
      //}
    }
    l = items.length;
    for (i = 0; i < l; i++) {
      obj = items[i];
      //if (obj.y < gameModel.levelHeight) {
      if (obj.tl) {
        obj.tl.play();
      }
      //}
    }
  };

  pixi.distributeItems = function (index) {
    var i, d, l, length, mid, hitTest, wall, item, rect,
      level = gameModel.levels[index],
      count = 0,
      minX = 18,
      maxX = 302,
      minY = 120,
      //maxY = level.height - 310,
      maxY = gameModel.levelHeight - 310,
      width = maxX - minX, //284
      walls = level.walls,
      items = level.collectableItems,
      testables = [],
      testitems = [];
    //prepare the searching for intersection of items
    //push mitarbeiter hornbach stapler and walls into testable array
    length = items.length;
    for (i = 0; i < length; i++) {
      item = items[i];
      if (item.name === 'item-mitarbeiter') {
        //rect = new lib.Rectangle(minX, item.y, width, item.height);
        //rect.name = item.name;
        testitems.push(item);
      } else if (item.name === 'item-hornbach') {
        rect = new lib.Rectangle(item.x, item.y, item.width, item.height);
        rect.inflate(20, 20);
        rect.name = item.name;
        testables.push(rect);
      } else {
        testitems.push(item);
        //console.log("pixi.distributeItems", "testitems item:", item);
      }
    }
    l = walls.length;
    for (i = 0; i < l; i++) {
      wall = walls[i];
      if (wall.name.indexOf('stapler-') !== -1) {
        rect = new lib.Rectangle(minX, wall.y, width, wall.height);
      } else {
        rect = new lib.Rectangle(wall.x, wall.y, wall.width, wall.height);
      }
      rect.inflate(20, 20);
      rect.name = wall.name;
      testables.push(rect);
    }
    //
    mid = Math.floor(testitems.length / 2);
    //console.log("pixi.distributeItems");
    //console.log("pixi.distributeItems", "testables:", JSON.parse(JSON.stringify(testables)));
    while (++count <= 300) {
      i = length = testitems.length;
      while (--i >= 0) {
        item = testitems[i];
        //find random x/y between min and max x values and level height
        if (item.name === 'item-mitarbeiter') {
          item.x = width;
        } else {
          item.x = pixi.randomInt(Math.ceil(minX + item.width), Math.floor(maxX - item.width));
        }
        item.y = (i > length / 2) ? pixi.randomInt(minY, (maxY - minY) / 2) : pixi.randomInt((maxY - minY) / 2, maxY);
        hitTest = false;
        l = testables.length;
        for (d = 0; d < l; d++) {
          rect = testables[d];
          //early out if item intersects
          hitTest = (item.name === 'item-mitarbeiter') ? rect.intersects(new lib.Rectangle(minX, item.y - 20, width, item.height + 20)) : rect.intersects(item);
          if (hitTest) {
            break;
          }
        }
        if (!hitTest) {
          //console.log("pixi.distributeItems", "item:", item);
          if (item.name === 'item-mitarbeiter') {
            item.sprite.x = item.x;
            rect = new lib.Rectangle(minX, item.y, width, item.height);
            rect.inflate(0, 10);
          } else {
            item.sprite.x = item.x + item.width / 2;
            rect = new lib.Rectangle(item.x, item.y, item.width, item.height);
            rect.inflate(10, 10);
          }
          item.sprite.y = item.y + item.height / 2;
          testitems.splice(i, 1);
          rect.name = item.name;
          testables.push(rect);
        }
      }
      if (testitems.length === 0) {
        break;
      }
    }
    //console.log("pixi.distributeItems", "level:", level);
    //console.log("pixi.distributeItems", "testables:", testables);
  };

  pixi.resetLevel = function (index) {
    var i, obj,
      level = gameModel.levels[index],
      walls = level.walls,
      items = level.collectableItems,
      l = walls.length;
    level.sprite.visible = false;
    for (i = 0; i < l; i++) {
      obj = walls[i];
      //if (obj.y < gameModel.levelHeight) {
      if (obj.tl) {
        obj.tl.pause();
      }
      //}
    }
    l = items.length;
    for (i = 0; i < l; i++) {
      obj = items[i];
      obj.collected = false;
      //if (obj.y < gameModel.levelHeight) {
      obj.sprite.visible = true;
      if (obj.tl) {
        obj.tl.pause();
      }
      //}
    }
    //console.log("resetLevel", "index:", index, "loop:", gameModel.loop);
  };

  pixi.restartLevel = function () {
    gsap.delayedCall(1.0, function () {
      //reset player
      gameModel.setX(gameModel.rectStage.width / 2 - gameModel.rectPlayer.width / 2);
      gameModel.setY(gameModel.rectStage.height - gameModel.levelHeight);
      gameModel.direction = 0;
      //set start position
      pixi.levels.getChildAt(gameModel.currentLevel).y = gameModel.y;
      pixi.levels.getChildAt(gameModel.getNextLevelIndex()).y = (gameModel.y - gameModel.levelHeight);
      pixi.movePlayer();
      if (gameModel.currentWall && gameModel.currentWall.tl) {
        gameModel.currentWall.tl.play();
      }
      gsap.delayedCall(0.2, function () {
        game.runGame();
        soundCtrl.play('hupe');
      });
    });
  };

  pixi.resetPlayerModus = function () {
    //console.log("resetPlayerModus");
    gameModel.playerModus = lib.GameModel.PLAYER_MODUS_NORMAL;
    gsap.killTweensOf(pixi.player);
    gsap.killTweensOf(pixi.player.children);
    pixi.player.alpha = 1;
    gsap.set(pixi.player.children, {
      pixi: {
        alpha: 1
      }
    });
    //gsap.set(pixi.trainCountdown.children, { pixi: { alpha: 0, scale: 1 } });
  };

  pixi.wallCollision = function (type) {
    var dur = 0.025;
    //console.log("wallCollision", 'type:', type);
    if (type === 'front') {
      gsap.set(pixi.trainExplosion, {
        y: 0
      });
    } else if (type === 'mid') {
      gsap.set(pixi.trainExplosion, {
        y: gameModel.rectPlayerStart.height
      });
    } else if (type === 'end') {
      gsap.set(pixi.trainExplosion, {
        y: gameModel.rectPlayerStart.height + gameModel.rectPlayerMid.height
      });
    }
    gsap.to(pixi.trainExplosion.children, {
      pixi: {
        alpha: 1
      },
      duration: dur,
      stagger: dur
    });
    gsap.to(pixi.trainExplosion.children, {
      pixi: {
        alpha: 0
      },
      duration: 1,
      delay: 0.5
    });
    gsap.to(pixi.player, {
      pixi: {
        alpha: 0
      },
      duration: 0.075,
      onComplete: function () {
        pixi.player.alpha = 1;
      },
      repeat: 3,
      yoyo: true,
      ease: 'power1.inOut',
      stagger: 0.03
    });
    //SOUND
    soundCtrl.play('crash');
  };

  pixi.setBeserkModus = function () {
    //console.log("setBeserkModus");
    //change from 'normal' to 'beserk'
    gameModel.playerModus = lib.GameModel.PLAYER_MODUS_BESERK;
    gsap.killTweensOf(pixi.player);
    gsap.killTweensOf(pixi.player.children);
    var i, child,
      l = gameModel.BESERK_TIME;
    for (i = 0; i < l; i++) {
      child = pixi.trainCountdown.getChildAt(i);
      gsap.set(child, {
        pixi: {
          alpha: 1,
          scale: 0.5
        },
        delay: i
      });
      gsap.to(child, {
        pixi: {
          alpha: 0,
          scale: 2
        },
        duration: 0.8,
        ease: 'power1.inOut',
        delay: i + 0.15
      });
    }
    gsap.to(pixi.player.children, {
      pixi: {
        alpha: 0.2
      },
      duration: 0.1,
      repeat: -1,
      yoyo: true,
      ease: 'power2.inOut',
      stagger: 0.02
    });
    gsap.delayedCall(gameModel.BESERK_TIME, pixi.resetPlayerModus);
  };

  pixi.removeCollectable = function (collectable) {
    gsap.set(collectable.sprite, {
      pixi: {
        alpha: 1,
        scale: 1.0,
        rotation: 0,
        x: collectable.x
      }
    });
    collectable.sprite.visible = false;
    if (collectable.tl) {
      collectable.tl.pause();
    }
  };

  pixi.checkCollectableCollision = function () {
    var i, collectable,
      level = gameModel.levels[gameModel.currentLevel],
      collectableItems = level.collectableItems,
      l = collectableItems.length,
      rectPlayer = gameModel.rectPlayer;
    //console.log("checkCollectableCollision", "x", gameModel.x, "y", gameModel.y, "playerStartY", gameModel.playerStartY, "rectPlayer", rectPlayer);
    for (i = 0; i < l; i++) {
      collectable = collectableItems[i];
      //console.log("checkCollectableCollision", 'rectPlayer:', rectPlayer, 'collectable:', collectable);
      if (!collectable.collected && rectPlayer.intersects(collectable)) {
        collectable.collected = true;
        game.setScore(collectable.score);
        if (collectable.name === 'item-mitarbeiter') {
          gsap.to(collectable.sprite, {
            pixi: {
              x: '+=100',
              alpha: 0
            },
            ease: 'power2',
            duration: 0.5,
            onComplete: pixi.removeCollectable,
            onCompleteParams: [collectable]
          });
          soundCtrl.play('mitarbeiter');
        } else {
          gsap.to(collectable.sprite, {
            pixi: {
              scale: 5.0,
              alpha: 0,
              rotation: 5
            },
            ease: 'power2',
            duration: 0.7,
            onComplete: pixi.removeCollectable,
            onCompleteParams: [collectable]
          });
          if (collectable.name === 'item-hornbach') {
            pixi.setBeserkModus();
            soundCtrl.play('booster');
          } else {
            soundCtrl.play('items');
          }
        }
        gameModel.collectedItems.push(collectable);
        break;
      }
    }
  };

  //
  pixi.createStapler = function (wall) {
    var tl, dur = 5.0,
      container = new Container(),
      childLeft = new Sprite(pixi.atlas["item-stapler.png"]),
      childRight = new Sprite(pixi.atlas["item-stapler-mirror.png"]);
    container.x = wall.x;
    container.y = wall.y;
    childLeft.cacheAsBitmap = true;
    childLeft.visible = false;
    container.addChild(childLeft);
    childRight.cacheAsBitmap = true;
    //childRight.visible = false;
    container.addChild(childRight);
    //create main timeline
    wall.tl = gsap.timeline({
      defaults: {
        ease: "power1.inOut",
        duration: dur
      },
      repeat: -1,
      onUpdate: function () {
        wall.x = container.x;
        //console.log("createStapler", "container.x:", container.x);
      }
    });
    wall.tl.call(function () {
      childLeft.visible = false;
      childRight.visible = true;
    }, [], 0);
    wall.tl.to(container, {
      x: wall.x + 200
    }, 0);
    wall.tl.call(function () {
      childRight.visible = false;
      childLeft.visible = true;
    }, [], dur);
    wall.tl.to(container, {
      x: wall.x
    }, dur);
    return container;
  };

  pixi.createMitarbeiter = function (item) {
    var dur = 6.5,
      container = new Container(),
      childLeft = new AnimatedSprite(resources[pixi.spriteJson].spritesheet.animations["item-mitarbeiter-left"]),
      childRight = new AnimatedSprite(resources[pixi.spriteJson].spritesheet.animations["item-mitarbeiter-right"]);
    /*childLeft = new Sprite(pixi.atlas["item-mitarbeiter-left-1.png"]),
    childRight = new Sprite(pixi.atlas["item-mitarbeiter-right-1.png"]);*/
    container.x = item.x;
    container.y = item.y;
    childLeft.animationSpeed = 0.1;
    childLeft.visible = false;
    container.addChild(childLeft);
    childRight.animationSpeed = 0.1;
    childRight.visible = false;
    container.addChild(childRight);
    //create main timeline
    item.tl = gsap.timeline({
      defaults: {
        ease: "power0",
        duration: dur
      },
      repeat: -1,
      onUpdate: function () {
        item.x = container.x;
        //console.log("createMitarbeiter", "container.x:", container.x);
      }
    });
    item.tl.call(function () {
      childLeft.visible = true;
      childLeft.play();
      childRight.stop();
      childRight.visible = false;
    }, [], 0);
    item.tl.to(container, {
      x: item.x - 260
    }, 0);
    item.tl.call(function () {
      childRight.visible = true;
      childRight.play();
      childLeft.stop();
      childLeft.visible = false;
    }, [], dur);
    item.tl.to(container, {
      x: item.x
    }, dur);
    //item.tl.add(tl);
    return container;
  };

  pixi.createItems = function (items) {
    var i, item,
      container = new Container(),
      length = items.length;
    for (i = 0; i < length; i++) {
      item = items[i];
      //item.rect = new lib.Rectangle(item.x, item.y, item.width, item.height);
      //console.log("pixi.createItems", "item:", item);
      if (item.name === 'item-mitarbeiter') {
        item.sprite = pixi.createMitarbeiter(item);
      } else {
        item.tl = gsap.timeline();
        item.sprite = new Sprite(pixi.atlas[item.name + ".png"]);
        item.sprite.cacheAsBitmap = true;
        item.sprite.x = item.x + item.width / 2;
        item.sprite.y = item.y + item.height / 2;
        item.sprite.anchor.set(0.5, 0.5);
        //move items up and down
        item.tl.to(item.sprite, {
          pixi: {
            scale: 1.25
          },
          duration: 0.5,
          delay: "random(0.05, 1.0)",
          repeat: -1,
          yoyo: true,
          repeatDelay: 0.25,
          ease: 'power2.in'
        });
      }
      if (item.y < gameModel.levelHeight) {
        container.addChild(item.sprite);
      }
    }
    return container;
  };

  pixi.createWalls = function (walls) {
    var i, wall, child,
      container = new Container(),
      length = walls.length;
    for (i = 0; i < length; i++) {
      wall = walls[i];
      //wall.rect = new lib.Rectangle(wall.x, wall.y, wall.width, wall.height);
      if (wall.name === 'stapler-0') {
        child = pixi.createStapler(wall);
      } else {
        child = new Sprite(pixi.atlas[wall.name + ".png"]);
        child.cacheAsBitmap = true;
      }
      //child.name = wall.name;
      //console.log("pixi.createWalls", "wall:", wall);
      child.x = wall.x;
      child.y = wall.y;
      if (wall.y < gameModel.levelHeight) {
        container.addChild(child);
      }
    }
    return container;
  };

  pixi.createLevel = function (index, level) {
    var container = new Container();
    container.name = level.name;
    //level.sprite = new TilingSprite(pixi.atlas[level.name + ".png"], gameModel.rectStage.width, gameModel.levelHeight);
    level.sprite = new Sprite(pixi.atlas[level.name + ".png"]);
    level.sprite.cacheAsBitmap = true;
    container.addChild(level.sprite);
    container.addChild(pixi.createWalls(level.walls));
    container.addChild(pixi.createItems(level.collectableItems));
    if (index === 0) {
      container.y = gameModel.y;
    } else {
      container.y = gameModel.y - gameModel.levelHeight;
    }
    level.sprite.visible = (index < 2);
    //console.log("pixi.createLevel", "index:", index, "name:", container.name, "y:", container.y, "level:", level);
    return container;
  };

  pixi.createPlayer = function () {
    var i, l, child,
      container = new Container(),
      //explosion = new Container(5, { alphaAndtint: true, scale: true, uvs: true }),
      explosion = new Container(),
      countdown = new Container();
    //
    container.x = gameModel.x;
    container.y = gameModel.playerStageY;
    child = new Sprite(pixi.atlas["train-start.png"]);
    child.name = 'start';
    child.anchor.set(0.5, 0.0);
    child.x = gameModel.rectPlayer.width / 2;
    container.addChild(child);
    child = new Sprite(pixi.atlas["train-mid.png"]);
    child.name = 'mid';
    child.anchor.set(0.5, 0.0);
    child.x = gameModel.rectPlayer.width / 2;
    child.y = gameModel.rectPlayerStart.height;
    container.addChild(child);
    child = new Sprite(pixi.atlas["train-end.png"]);
    child.name = 'end';
    child.anchor.set(0.5, 0.0);
    child.x = gameModel.rectPlayer.width / 2;
    child.y = gameModel.rectPlayerStart.height + gameModel.rectPlayerMid.height;
    container.addChild(child);
    for (i = 0; i < 5; i++) {
      child = new Sprite(pixi.atlas["train-ffx-" + (i + 1) + ".png"]);
      child.alpha = 0;
      child.anchor.set(0.5, 0.0);
      child.x = gameModel.rectPlayer.width / 2;
      explosion.addChild(child);
    }
    //explosion.visible = false;
    container.addChild(explosion);
    l = gameModel.BESERK_TIME;
    //
    for (i = l; i > 0; i--) {
      child = new Sprite(pixi.atlas["font-" + i + ".png"]);
      child.alpha = 0;
      child.anchor.set(0.5, 0.5);
      child.x = gameModel.rectPlayer.width / 2;
      child.y = gameModel.rectPlayer.width / 2;
      //child.width = gameModel.rectPlayer.width;
      countdown.addChild(child);
    }
    container.addChild(countdown);
    explosion.name = 'explosion';
    return container;
  };

  pixi.nextLevel = function () {
    var currIndex = gameModel.currentLevel,
      currentLevelChild = pixi.levels.getChildAt(currIndex),
      nextIndex = gameModel.getNextLevelIndex(),
      //nextLevelChild = pixi.levels.getChildAt(nextIndex),
      secondIndex = gameModel.getNextLevelIndexFrom(nextIndex);
    //secondLevelChild = pixi.levels.getChildAt(secondIndex);
    //
    //1.
    //game.pauseGame();
    //2.
    gameModel.setY(gameModel.rectStage.height - gameModel.levelHeight);
    //3.
    currentLevelChild.y = gameModel.y - gameModel.levelHeight;
    //currentLevelChild.visible = false;
    //4.
    pixi.resetLevel(currIndex);

    //5.
    gameModel.currentLevel = nextIndex;
    if (nextIndex === 0) {
      gameModel.loop++;
      gameModel.scrollSpeedY = Math.min(gameModel.SCROLL_SPEED_Y_MAX, gameModel.scrollSpeedY + gameModel.SCROLL_SPEED_ACC);
    }
    gameModel.scrollSpeedY = Math.min(gameModel.SCROLL_SPEED_Y_MAX, gameModel.scrollSpeedY + gameModel.SCROLL_SPEED_ACC);
    //6.
    pixi.activateLevel(nextIndex);
    //nextLevelChild.visible = true;
    pixi.activateLevel(secondIndex);
    //secondLevelChild.visible = true;
    //7.
    pixi.distributeItems(currIndex);
    //game.runGame();
    //console.log("nextLevel", 'scrollSpeedY:', gameModel.scrollSpeedY, 'nextIndex:', nextIndex, 'currIndex:', currIndex, 'gameModel.y:', gameModel.y, 'loop:', gameModel.loop);
  };

  pixi.movePlayer = function () {
    //console.log("movePlayer", "x", gameModel.x, "y", gameModel.y, "playerStartY", gameModel.playerStartY, "playerStageY", gameModel.playerStageY, "direction", gameModel.direction, "offset", offset);
    var x = gameModel.rectPlayer.width / 2;
    pixi.player.x = gameModel.x;
    if (gameModel.direction > 0) {
      //right
      pixi.trainMid.x = x - gameModel.OFFSET_TRAIN;
      pixi.trainEnd.x += (pixi.trainMid.x - pixi.trainEnd.x) * 0.75;
    } else if (gameModel.direction < 0) {
      //left
      pixi.trainMid.x = x + gameModel.OFFSET_TRAIN;
      pixi.trainEnd.x += (pixi.trainMid.x - pixi.trainEnd.x) * 0.75;
    } else {
      //center
      pixi.trainMid.x += (x - pixi.trainMid.x) * 0.25;
      pixi.trainEnd.x += (x - pixi.trainEnd.x) * 0.1;
    }
  };

  pixi.state = function (delta) {};
  pixi.stateDebug = function (delta) {

  };
  pixi.statePause = function (delta) {
    pixi.movePlayer();
    //console.log("statePause", "delta:", delta);
    pixi.app.renderer.render(pixi.app.stage);
  };
  pixi.stateRun = function (delta) {
    // update player model
    gameModel.update(delta);
    // check for player boundaries
    gameModel.checkPlayerBoundaries();
    //first collect
    pixi.checkCollectableCollision();
    //then may be wall collision
    if (gameModel.playerModus !== 'beserk') {
      var wallCollisionType = gameModel.checkPlayerWallCollision();
      //front mid end
      if (wallCollisionType !== '') {
        game.pauseGame();
        game.setLife(-1);
        pixi.wallCollision(wallCollisionType);
      }
    }
    // check for ground boundaries
    if (!gameModel.checkGroundBoundaries()) {
      pixi.nextLevel();
    }
    //pixi.tiling.
    pixi.levels.getChildAt(gameModel.currentLevel).y = gameModel.y;
    pixi.levels.getChildAt(gameModel.getNextLevelIndex()).y = (gameModel.y - gameModel.levelHeight);
    pixi.movePlayer();
    //console.log("stateRun", "delta:", delta);
    //pixi.app.renderer.render(pixi.app.stage);
  };

  pixi.createScroller = function () {
    console.log("");
    var i, sprite, tSprite, gt, graphics, texture,
      height = 0,
      numLevels = 5,
      levels = gameModel.levels,
      length = levels.length,
      renderer = PIXI.autoDetectRenderer(),
      renderTextureOptions = {
        width: gameModel.rectStage.width,
        height: gameModel.rectStage.height
      },
      renderTexture = PIXI.RenderTexture.create(renderTextureOptions);
    //pixi.scroller = new Container();
    //create views pixi.atlas["level-1.png"]
    /* for (i = 0; i < numLevels; i++) {
        renderTextureOptions.height += levels[i].height;
    } */
    //renderTexture = PIXI.RenderTexture.create(renderTextureOptions);
    /* for (i = 0; i < numLevels; i++) {
        sprite = new Sprite(pixi.atlas["level-" + (i + 1) + ".png"]);
        sprite.x = 0;
        sprite.y = height;
        sprite.anchor.set(0.0, 0.0);
        renderer.render(sprite, renderTexture);
        height += levels[i].height;
    } */

    //sprite = new Sprite(pixi.atlas["level-1.png"]);
    graphics = new Graphics();
    graphics.beginFill(0xFF3300);
    //graphics.beginTextureFill({ texture: sprite.texture, color: 0x101010 });
    graphics.drawRect(0, 0, gameModel.rectStage.width, gameModel.rectStage.height);
    graphics.endFill();
    //texture = pixi.app.renderer.generateTexture(graphics);
    sprite = new Sprite(pixi.atlas["level-1.png"]);
    sprite.x = 0;
    sprite.y = 0;
    pixi.app.stage.addChild(sprite);
    renderer.render(pixi.app.stage);
    gt = renderer.render(sprite, renderTexture);
    console.log("pixi.createScroller", "gt:", gt);

    /* gsap.delayedCall(0.1, function () {
        tSprite = new Sprite(gt);
        tSprite.x = 0;
        tSprite.y = 100;
        pixi.app.stage.addChild(tSprite);
    }); */


    //sprite.visible = false;
    //tSprite = new TilingSprite(renderTexture, gameModel.rectStage.width, gameModel.rectStage.height);
    //pixi.scroller.tilePosition.y = 2000;
    //
    //pixi.app.stage.addChild(pixi.scroller);


  };

  pixi.setup = function (lod, reso) {
    var i, level, graphics,
      levels = gameModel.levels,
      length = levels.length;
    //console.log("");
    //console.log("pixi.setup", "lod:", lod);
    //console.log("pixi.setup", "reso:", reso);
    //create texture atlas
    pixi.atlas = resources[pixi.spriteJson].textures;
    //
    pixi.levels = new Container();
    pixi.app.stage.addChild(pixi.levels);
    for (i = 0; i < length; i++) {
      level = levels[i];
      pixi.levels.addChild(pixi.createLevel(i, level));
    }
    //and mask them
    graphics = new Graphics();
    graphics.beginFill(0xFF3300);
    graphics.drawRect(0, 0, gameModel.rectStage.width, gameModel.rectStage.height);
    graphics.endFill();
    //assign graphics as mask to levels container
    pixi.levels.mask = graphics;

    pixi.player = pixi.createPlayer();
    pixi.trainStart = pixi.player.getChildByName('start');
    pixi.trainMid = pixi.player.getChildByName('mid');
    pixi.trainEnd = pixi.player.getChildByName('end');
    pixi.trainExplosion = pixi.player.getChildAt(3);
    pixi.trainCountdown = pixi.player.getChildAt(4);
    pixi.app.stage.addChild(pixi.player);
    //
    //console.log("pixi.setup", "pixi.trainExplosion:", pixi.trainExplosion);
    //console.log("pixi.setup", "pixi.trainCountdown:", pixi.trainCountdown);
    //console.log("pixi.setup", "gameModel:", gameModel);
    if (isloaded) {
      game.initialize();
    }
  };

  /**
   * ENTRY POINT *
   * game.createUI -> game.loadPixi -> game.initPixi -> pixi.setup -> game.initialize
   */
  window.enterEGPGame = function (version, modified) {
    game.version = version;
    game.modified = modified;
    //console.log("gameData:", gameData);
    //console.log("languageData:", languageData);
    //
    $('body').removeClass('desktop mobile').addClass(OS_SYSTEM === 'desktop' ? 'desktop' : 'mobile');
    //
    window.addEventListener('load', function () {
      //initialize game
      game.initGame();
      resize();
      //game.createUI -> game.loadPixi -> game.initPixi -> pixi.setup -> game.initialize
      game.createUI(function created() {
        //console.log("createUI", "created");
        gsap.fromTo($startBtn, {
          scale: 2,
          opacity: 0
        }, {
          scale: 1,
          opacity: 1,
          ease: 'back.inOut',
          delay: 0.5,
          duration: 0.6,
          onStart: function () {
            $startBtn.removeClass('hidden');
          }
        });
        game.registerEvents();
      }, function done() {
        //console.log("createUI", "done");
        //$loader.hide();

        //game.loadPixi(game.initPixi);
      });

    }, false);
    //stop scaling on iOS
    if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
      window.document.addEventListener('touchmove', function (e) {
        if (e.scale !== 1) {
          e.preventDefault();
        }
      }, {
        passive: false
      });
    }
    if (OS_SYSTEM === 'desktop') {
      window.addEventListener("resize", function () {
        setTimeout(function () {
          //console.log("");
          //console.log("OS_SYSTEM", OS_SYSTEM);
          //console.log("gameModel.state", gameModel.state);
          //console.log("the orientation of the device is now " + window.screen.orientation.angle);
          if (gameModel.state === lib.GameModel.STATE_INTRO || gameModel.state === lib.GameModel.STATE_LOAD) {
            resize();
            game.resizeGame();
          }
        });
      });
    }
  };

}(jQuery));
